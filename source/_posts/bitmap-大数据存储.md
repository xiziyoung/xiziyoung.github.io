---
title: bitmap-大数据存储
categories:
- 算法
date: 2020-02-26 14:37:20
tags:
- algorithm
---
二进制数据是用0和1两个数码来表示的数。 它的基数为2，进位规则是"逢二进一"，借位规则是"借一当二"。  
计算机是用数字电路搭成的，数字电路中只有1和0两种状态。     
我们可以利用二进制0和1代表两种不同的状态,来记录很多东西。例如是否登录,或者其他状态记录，但是该状态应该只有两种表现形式，因为二进制只有0和1只能记录两种不同的状态。

# 举例一:
- - -
例如一个用户信息表,里面要记录爱好:   
其中爱好有多个(篮球,羽毛球,足球,游戏,音乐......),供用户填写资料时勾选(可多选);   
传统的做法可以分表: 分为一个主要的用户表user(id, name), 一个爱好表hobby(id,hobby),然后一个中间表(id,user_id,hobby_id)关联用户id和爱好id;   
bitmap做法:只需要一个用户表,然后爱好字段也存入用户表user(id,name,hobby);采用位运算来存储和查询;   
二进制结构:   

代表的爱好  |	二进制值  |	十进制数值 
---      |:--:       |---:
(类型一) 篮球      |	000001  |   1   
(类型二) 羽毛球    |000010   | 2
(类型三) 足球      |000100	| 4
(类型四) 游戏      |001000	| 8
(类型五) 音乐      |010000	| 16

纵观二进制值的数据列,我们可以发现代表每种爱好类型的二进制对应的位数据为1,其他位为0;这正是bitmap的关键所在;   

**位运算**(存储是用或运算, 查询时用与运算):   

 例子 |	名称  |	结果 
---      |:--:       |---:
$a & $b	 | And（按位与）|	将把 $a 和 $b 中都为 1 的位设为 1。
$a \| $b |	Or（按位或）|	将把 $a 和 $b 中任何一个为 1 的位设为 1。

存储时:   
那么当一个用户(小明)同时勾选选篮球和羽毛球这两个爱好时, 我们将爱好的二进制进行 [或] 运算   
000001 |  000010  =  000011 (即10进制的3)   
然后当一个用户(小李)同时勾选选篮球,羽毛球,游戏这三个爱好时:   
000001 |  000010 | 001000 =  001011 (即10进制的11)   
此时的数据表:   

id	| name	| hobby
---      |:--:    |---:
1	| 小明	| 3
2	| 小李	| 11

查询是:   
例如查找都爱好羽毛球的用户:   
羽毛球的二进制为:000010, 我们拿小明的hobby = 3(即二进制 000011) 和羽毛球的二进制值进行 [与] 运算:   
000011 & 000010 = 000010 即数值3>0, 得到小明爱好有羽毛球   
同理:小李查找位运算 [hobby | 羽毛球] 为:     
001011 & 000010 = 000010  > 0, 小李也爱好羽毛球;   

mysql本身支持位运算查询:   
SELECT * FROM `user` where  hobby&2 > 0; (即可查到小明和小李);   

# 举例二 
- - -
以下示例中二进制位0,1分别代码未签到,已签到两种状态;      
例如有个需求，（1）记录每个用户每天是否签到（2）统计某一个月没有断签的用户（3）查看某个用户连续签到的情况        
## 常规方式： 
使用一张签到log表,字段user_id, date;     
每次用户签到就在该log表中记录下用户id和签到日期;   
针对需求(2)统计没有断签也简单啊,where 月份区间 count一下看天数是否满足;    
针对需求(3)可以加个字段记录是否连续签到;       
但是这样的话每天1000万的用户签到就是1000万条记录数据,一年就是365*1000万的数据量;      

## 使用bitmap
利用二进制的0和1分别代表<未签到,签到>两种不同的状态;       
签到log表:字段user_id, year, mouth, record(该用户当月签到记录)(int);         

假设小明 user_id 为100, 18年的3月份他分别在1,2,3,10,20,30,31号进行了签到;         
利用二进制位(此处采用32位)来表示小明该月份的签到情况如下:        
(下面32位数字,从左往右分别带表3月1号到32号,不要纠结没有32号)        
 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 1        
该数值转为十进制为1611137543     
所以log表中表示小明该月签到的情况为:           
         
user_id  |	year  |	mouth | record
---      |:--:    |:--:   |---:
100      |	2018  |   3   | 1611137543

这样, 一条sql记录就能存储一个用户一个月的签到情况了;       
     
### 说明:   
在很多情况下,我们可能需要的是记录某一天有多少个会员的签到情况,而不是某个会员的签到情况,这个怎么使用bitmap了      
我们需要采用会员id横向存储,以天为单位,把签到的会员id存入数据中,数据库只需要查询某一天的bitmap数据,就能得到某一天的所有会员签到情况;    
签到log表设计: date(日期), section(用户id/32向上取整落在的区间段值),user_ids_record(对应id用户在该日期签到的情况)(int);     
假设 user_id为1,10,20,32,100,1000,10000的用户在2018-3-10签到了:           
(1).利用这些用户id除以32取整;为什么除以32,是因为mysql的int类型是32位(即4字节的8位);          
(2).不同用户id对应**section**的取值:         
1,10,20,32 除以32 向上取整为1,所以这些用户id对应的section=1;       
100,1000,10000 除以32 向上取整分别为4,32,313;        
(3).不同用户id在**user_ids_record**所处的位置:      
user_id%32的值, 即用户id取模32的值即该用户在user_ids_record表示的32个二进制位中的位置(从左往右);     
例如100/32向上取整为4,100%32也为4,那么如果区间4只有100这个用户签到就会有这样一条记录:2018-3-10,4,8(二进制数为1000);         
(4).最终2018-3-10的签到记录表如下(这一天只有user_id为1,10,20,32,100,1000,10000这些用户签到了):          

date  |	section  |	user_ids_record | 备注的二进制值
---      |:--:    |:--:   |---:
2018-3-10 |	1    |   2148008449   | 10000000000010000000001000000001
2018-3-10 |	4    |   8            | 00000000000000000000000000001000
2018-3-10 |	32   |   128          | 00000000000000000000000010000000
2018-3-10 |	313  |   32768        | 00000000000000001000000000000000

如果上面的例子采用mysql的数据类型为**BIGINT**(占用8个字节,即64位),则一条记录可以存储64个用户的签到情况;

**tips**:

<table><tr><td bgcolor="#E6E6FA">
计算机存储信息的最小单位，称之为位（bit，又称比特）; 
存储器中所包含存储单元的数量称为存储容量，其计量基本单位是字节（Byte。简称B），8个二进制位称为1个字节，此外还有KB、MB、GB、TB等，它们之间的换算关系是:
1Byte＝8bit，1KB=1024B，1MB=1024KB，1GB=1024MB，1TB=1024GB。

所谓的位指的是CPU一次数据读取的最大量！64位CPU代表CPU一次可以读写64bits这
么多的数据，32位CPU则是CPU一次只能读取32位的意思。 因为CPU读取数据量有限制，因
此能够从内存中读写的数据也就有所限制。所以，一般32位的CPU所能读写的最大数据量，
大概就是4GB左右.
</td></tr></table>


# bitmap的缺点:
- - -    
bitmap不能存储多状态情况,bitmap只有0和1 两个状态,无法做多状态的存储;     
bitmap不能存储重复数据,bitmap是通过不同的位数,代表不同的数据和不同的状态,不能通过bitmap存储重复的数据;       
bitmap受int位数限制,在32位机器上,int只有32位4个字节,所以你一个int数据只能最多存储32条数据.(有些语言的int类型在32/64位机器上的位数大小和其语言的解释器有关)        

**tips**:
<table><tr><td bgcolor="#EEE8AA">
redis的bitmap很适合做记录签到登录这类的功能
</td></tr></table>    