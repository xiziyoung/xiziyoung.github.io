<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bitmap-大数据存储]]></title>
    <url>%2F2020%2F02%2F26%2Fbitmap-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[二进制数据是用0和1两个数码来表示的数。 它的基数为2，进位规则是”逢二进一”，借位规则是”借一当二”。计算机是用数字电路搭成的，数字电路中只有1和0两种状态。我们可以利用二进制0和1代表两种不同的状态,来记录很多东西。例如是否登录,或者其他状态记录，但是该状态应该只有两种表现形式，因为二进制只有0和1只能记录两种不同的状态。 举例一: 例如一个用户信息表,里面要记录爱好:其中爱好有多个(篮球,羽毛球,足球,游戏,音乐……),供用户填写资料时勾选(可多选);传统的做法可以分表: 分为一个主要的用户表user(id, name), 一个爱好表hobby(id,hobby),然后一个中间表(id,user_id,hobby_id)关联用户id和爱好id;bitmap做法:只需要一个用户表,然后爱好字段也存入用户表user(id,name,hobby);采用位运算来存储和查询;二进制结构: 代表的爱好 二进制值 十进制数值 (类型一) 篮球 000001 1 (类型二) 羽毛球 000010 2 (类型三) 足球 000100 4 (类型四) 游戏 001000 8 (类型五) 音乐 010000 16 纵观二进制值的数据列,我们可以发现代表每种爱好类型的二进制对应的位数据为1,其他位为0;这正是bitmap的关键所在; 位运算(存储是用或运算, 查询时用与运算): 例子 名称 结果 $a &amp; $b And（按位与） 将把 $a 和 $b 中都为 1 的位设为 1。 $a | $b Or（按位或） 将把 $a 和 $b 中任何一个为 1 的位设为 1。 存储时:那么当一个用户(小明)同时勾选选篮球和羽毛球这两个爱好时, 我们将爱好的二进制进行 [或] 运算000001 | 000010 = 000011 (即10进制的3)然后当一个用户(小李)同时勾选选篮球,羽毛球,游戏这三个爱好时:000001 | 000010 | 001000 = 001011 (即10进制的11)此时的数据表: id name hobby 1 小明 3 2 小李 11 查询是:例如查找都爱好羽毛球的用户:羽毛球的二进制为:000010, 我们拿小明的hobby = 3(即二进制 000011) 和羽毛球的二进制值进行 [与] 运算:000011 &amp; 000010 = 000010 即数值3&gt;0, 得到小明爱好有羽毛球同理:小李查找位运算 [hobby | 羽毛球] 为:001011 &amp; 000010 = 000010 &gt; 0, 小李也爱好羽毛球; mysql本身支持位运算查询:SELECT * FROM user where hobby&amp;2 &gt; 0; (即可查到小明和小李); 举例二 以下示例中二进制位0,1分别代码未签到,已签到两种状态;例如有个需求，（1）记录每个用户每天是否签到（2）统计某一个月没有断签的用户（3）查看某个用户连续签到的情况 常规方式：使用一张签到log表,字段user_id, date;每次用户签到就在该log表中记录下用户id和签到日期;针对需求(2)统计没有断签也简单啊,where 月份区间 count一下看天数是否满足;针对需求(3)可以加个字段记录是否连续签到;但是这样的话每天1000万的用户签到就是1000万条记录数据,一年就是365*1000万的数据量; 使用bitmap利用二进制的0和1分别代表&lt;未签到,签到&gt;两种不同的状态;签到log表:字段user_id, year, mouth, record(该用户当月签到记录)(int); 假设小明 user_id 为100, 18年的3月份他分别在1,2,3,10,20,30,31号进行了签到;利用二进制位(此处采用32位)来表示小明该月份的签到情况如下:(下面32位数字,从左往右分别带表3月1号到32号,不要纠结没有32号) 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 1该数值转为十进制为1611137543所以log表中表示小明该月签到的情况为: user_id year mouth record 100 2018 3 1611137543 这样, 一条sql记录就能存储一个用户一个月的签到情况了; 说明:在很多情况下,我们可能需要的是记录某一天有多少个会员的签到情况,而不是某个会员的签到情况,这个怎么使用bitmap了我们需要采用会员id横向存储,以天为单位,把签到的会员id存入数据中,数据库只需要查询某一天的bitmap数据,就能得到某一天的所有会员签到情况;签到log表设计: date(日期), section(用户id/32向上取整落在的区间段值),user_ids_record(对应id用户在该日期签到的情况)(int);假设 user_id为1,10,20,32,100,1000,10000的用户在2018-3-10签到了:(1).利用这些用户id除以32取整;为什么除以32,是因为mysql的int类型是32位(即4字节的8位);(2).不同用户id对应section的取值:1,10,20,32 除以32 向上取整为1,所以这些用户id对应的section=1;100,1000,10000 除以32 向上取整分别为4,32,313;(3).不同用户id在user_ids_record所处的位置:user_id%32的值, 即用户id取模32的值即该用户在user_ids_record表示的32个二进制位中的位置(从左往右);例如100/32向上取整为4,100%32也为4,那么如果区间4只有100这个用户签到就会有这样一条记录:2018-3-10,4,8(二进制数为1000);(4).最终2018-3-10的签到记录表如下(这一天只有user_id为1,10,20,32,100,1000,10000这些用户签到了): date section user_ids_record 备注的二进制值 2018-3-10 1 2148008449 10000000000010000000001000000001 2018-3-10 4 8 00000000000000000000000000001000 2018-3-10 32 128 00000000000000000000000010000000 2018-3-10 313 32768 00000000000000001000000000000000 如果上面的例子采用mysql的数据类型为BIGINT(占用8个字节,即64位),则一条记录可以存储64个用户的签到情况; tips: 计算机存储信息的最小单位，称之为位（bit，又称比特）; 存储器中所包含存储单元的数量称为存储容量，其计量基本单位是字节（Byte。简称B），8个二进制位称为1个字节，此外还有KB、MB、GB、TB等，它们之间的换算关系是: 1Byte＝8bit，1KB=1024B，1MB=1024KB，1GB=1024MB，1TB=1024GB。 所谓的位指的是CPU一次数据读取的最大量！64位CPU代表CPU一次可以读写64bits这么多的数据，32位CPU则是CPU一次只能读取32位的意思。 因为CPU读取数据量有限制，因此能够从内存中读写的数据也就有所限制。所以，一般32位的CPU所能读写的最大数据量，大概就是4GB左右. bitmap的缺点: bitmap不能存储多状态情况,bitmap只有0和1 两个状态,无法做多状态的存储;bitmap不能存储重复数据,bitmap是通过不同的位数,代表不同的数据和不同的状态,不能通过bitmap存储重复的数据;bitmap受int位数限制,在32位机器上,int只有32位4个字节,所以你一个int数据只能最多存储32条数据.(有些语言的int类型在32/64位机器上的位数大小和其语言的解释器有关) tips: redis的bitmap很适合做记录签到登录这类的功能]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解laravel中的Ioc容器,依赖注入]]></title>
    <url>%2F2019%2F07%2F26%2F%E7%90%86%E8%A7%A3laravel%E4%B8%AD%E7%9A%84Ioc%E5%AE%B9%E5%99%A8%2C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[反射:PHP 5 开始 具有完整的反射 API，添加了对类、接口、函数、方法和扩展进行反向工程的能力。 此外，反射 API 提供了方法来取出函数、类和方法中的文档注释。反射是一切框架的基础;参考 : https://www.php.net/manual/zh/book.reflection.php 首先我们来下下面这个例子:在laravel框架中,很多对象实例通过方法参数定义就能传递进来，调用的时候不需要我们自己去手动传入对象实例。类似这样: 12345678910111213141516// routes/web.phpRoute::get('/post/store', 'PostController@store');// App\Http\Controllersclass PostController extends Controller &#123; public function store(Illuminate\Http\Request $request) &#123; $this-&gt;validate($request, [ 'category_id' =&gt; 'required', 'title' =&gt; 'required|max:255|min:4', 'body' =&gt; 'required|min:6', ]); &#125;&#125; 如上, 我们在调用控制器中store的时候, Request类的实例是什么时候传入的了, 我们并没有手动传入该对象实例; 这便是依赖注入,Ioc容器和php反射来实现的; 依赖注入:https://github.com/xiziyoung/Notes/blob/master/php-design-pattern/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.md IOC看下面的利用ioc容器技术来实现记录用户登录日志的例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?php// 定义写日志的接口规范interface Log&#123; public function write();&#125;// 文件记录日志class FileLog implements Log&#123; public function write() &#123; echo 'file log write...' . PHP_EOL; &#125;&#125;// 数据库记录日志class DatabaseLog implements Log&#123; public function write() &#123; echo 'database log write...' . PHP_EOL; &#125;&#125;class User&#123; protected $fileLog; protected $time; protected $account; public function __construct(Log $log, $account, $time) &#123; $this-&gt;fileLog = $log; $this-&gt;time = $time; $this-&gt;account = $account; &#125; public function login() &#123; echo $this-&gt;account . ' login success... at ' . $this-&gt;time . PHP_EOL; $this-&gt;fileLog-&gt;write(); &#125;&#125;class Ioc&#123; public $binding = []; public function bind($abstract, $concrete) &#123; $this-&gt;binding[$abstract]['concrete'] = function ($ioc, array $parameters) use ($concrete) &#123; return $ioc-&gt;build($concrete, $parameters); &#125;; &#125; public function make($abstract, $parameters = []) &#123; $concrete = $this-&gt;binding[$abstract]['concrete']; return $concrete($this, $parameters); &#125; public function build($concrete, array $parameters) &#123; $reflector = new ReflectionClass($concrete); //https://www.php.net/manual/zh/book.reflection.php $constructor = $reflector-&gt;getConstructor(); if (is_null($constructor)) &#123; return $reflector-&gt;newInstance(); &#125; else &#123; $dependencies = $constructor-&gt;getParameters(); $instances = $this-&gt;getDependencies($dependencies, $parameters); return $reflector-&gt;newInstanceArgs($instances); &#125; &#125; protected function getDependencies($paramters, array $parameters) &#123; $dependencies = []; foreach ($paramters as $paramter) &#123; $class = $paramter-&gt;getClass()-&gt;name; //https://www.php.net/manual/en/reflectionparameter.getclass.php if (is_null($class)) &#123; $dependencies[] = array_shift($parameters); &#125; else &#123; $dependencies[] = $this-&gt;make($class); &#125; &#125; return $dependencies; &#125;&#125;$ioc = new Ioc();$ioc-&gt;bind('User', 'User');$ioc-&gt;bind('Log', 'FileLog');$user = $ioc-&gt;make('User', ['123@qq.com', date('Y-m-d H:i:s')]);$user-&gt;login();$ioc-&gt;bind('Log', 'DatabaseLog');$user = $ioc-&gt;make('User', ['456@qq.com', date('Y-m-d H:i:s')]);$user-&gt;login();]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>laravel,设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php递归和引用实现的无限极分类]]></title>
    <url>%2F2019%2F07%2F12%2Fphp%E9%80%92%E5%BD%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[无限极分类类似省、市、区,构建成一个父级下面有多个子元素的数据结构;子元素与父元素之间通常使用id和parentId来关联; php递归实现无限极分类:该方法实现的无限极分类在数据量和子层级较多时,很慢,因为递归调用每次都要遍历大量的数据;代码示例: 1234567891011121314151617181920212223&lt;?phpfunction buildTreeByRecursion(array $elements, $rootValue = 0, $parentField = "parent", $index = '', $level = 0)&#123; $branch = array(); $level++; foreach ($elements as $k =&gt; $element) &#123; $element['_level'] = $level; if ($element[$parentField] == $rootValue) &#123; unset($elements[$k]);//减轻下次递归时遍历的数量 $children = buildTreeByRecursion($elements, $element['id'], $parentField, $index, $level); if ($children) &#123; $element['children'] = $children; &#125; if (empty($index)) &#123; $branch[] = $element; &#125; else &#123; $branch[$element[$index]] = $element; &#125; &#125; &#125; return $branch;&#125; php引用传值方式实现无限极分类首先我们看下简单php的引用传值: 12345678910111213141516171819&lt;?php$list = [ 0 =&gt; ['id' =&gt; 1,], 1 =&gt; ['id' =&gt; 2,], 2 =&gt; ['id' =&gt; 3,]];$tree = [ 0 =&gt; &amp;$list[0], 1 =&gt; &amp;$list[1], 2 =&gt; $list[2],];var_dump($tree);$list[0]['children'] = ['first new child'];$list[1]['children'] = ['second new child'];$list[2]['children'] = ['third new child'];var_dump($tree);exit(); php的应用传值是将变量对应的内存地址指向同一个地址,即$a = &amp;$b;那么修改$a或者$b的值,实际相当于修改的是他们在内存中的地址处的值, 那么两个变量的值都将变化,因为他们的地址指向的值变了; 地址引用无限极分类:该方法很快, 因为不用像递归那样多次遍历数据; 12345678910111213141516171819202122&lt;?phpfunction getTreeByQuote($list, $pid = 0, $parentField = 'parent')&#123; $tree = []; if (!empty($list)) &#123; //第一步 构造数据:修改为以id为下标的列表 $newList = []; foreach ($list as $k =&gt; $v) &#123; $newList[$v['id']] = $v; &#125; //第二步: 遍历数据,生成树状结构 foreach ($newList as $value) &#123; if ($pid == $value[$parentField]) &#123; $tree[] = &amp;$newList[$value['id']]; &#125; elseif (isset($newList[$value[$parentField]])) &#123; $newList[$value[$parentField]]['children'][] = &amp;$newList[$value['id']]; &#125; &#125; &#125; return $tree;&#125; 测试: 1234567891011121314151617181920&lt;?php/*** 前面的递归和引用实现无限极分类函数 */$data = file_get_contents('./category.json');$data = json_decode($data, true);$_base_time = time();$_base = memory_get_usage();//$res = buildTreeByRecursion($data, 0, 'parentId');$res = getTreeByQuote($data, 0, 'parentId');$_end_time = time();$_end = memory_get_usage();var_dump('内存使用'.(int)(($_end-$_base)/1024).'kb'); var_dump('时间使用'.($_end_time-$_base_time).'s');var_dump($res);exit();echo json_encode($res, JSON_UNESCAPED_UNICODE);exit(); 测试数据: 4818条数据,其中一级44个,二级元素452个,三级元素4326个;递归方式,内存使用2082kb,时间使用11s;引用方式,内存使用608kb,时间使用0s;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql幻读]]></title>
    <url>%2F2019%2F07%2F05%2Fmysql%E5%B9%BB%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[事务隔离级别mysql 有四级事务隔离级别: (图来自: &lt;高性能mysql一书&gt;) 解释: 脏读: 在事务T1中可以读取到事务T2中还没提交的更新; 不可重复读: 事务T1能够读取到事务T2提交后的更新, 这将导致事务T1在T2提交前后读取到的数据不一样, 即不可重复读; 幻读: 幻读，并不是指在同一事务中执行两次同样的sql语句获取到的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。 幻读举例: 1.幻读的产生:下面用REPEATABLE-READ隔离级别举例说明 查看看事务隔离级别和测试表(innodb存储引擎的表)结构: 12345678910111213141516171819202122232425262728293031mysql&gt; select @@global.tx_isolation, @@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in setmysql&gt; mysql&gt; desc test;+-------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(255) | NO | | NULL | |+-------+--------------+------+-----+---------+----------------+2 rows in set (1). 事务T1中123456789mysql&gt; begin;Query OK, 0 rows affectedmysql&gt; select * from test where id =1;Empty setmysql&gt; (2). 事务T2:1234567891011121314151617181920212223242526272829mysql&gt; begin;Query OK, 0 rows affectedmysql&gt; select * from test where id =1;Empty setmysql&gt; insert into test values (1, &apos;first&apos;);Query OK, 1 row affectedmysql&gt; commit;Query OK, 0 rows affectedmysql&gt; select * from test where id =1;+----+-------+| id | name |+----+-------+| 1 | first |+----+-------+1 row in set (3). 回到事务T1中:12345678910111213mysql&gt; select * from test where id =1;Empty setmysql&gt; insert into test values(1, &apos;second&apos;);1062 - Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;mysql&gt; mysql&gt; select * from test where id =1;Empty set 我们可以看到在T2事务的中途干扰下, 导致T1事务出现了幻读 : 在事务T1中查询 id=1的数据不存在, 但指定id为1插入数据时又会抛出错误 Duplicate entry ‘1’ for key ‘PRIMARY’ , 然后我们在出现插入错误提示后, 在T1中查询id=1的数据还是不存在。 2.SERIALIZABLE防止幻读的方式因为在该隔离级别下, 会给读取到的每一条数据强制加锁 (数据行存在加 X锁, 不存在的加Gap Lock锁 ), 即记录存在与否，mysql 都会对记录应该对应的索引加锁，其他事务是无法再获得做操作的。 MySQL InnoDB支持三种行锁定方式： 行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key。 间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而已的。 Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql优化]]></title>
    <url>%2F2019%2F04%2F08%2Fmysql%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[查询优化, 索引优化, 库表机构优化 需要齐头并进, 一个不落 查询优化和索引优化 多用DESC 或者 EXPLAIN分析查询情况; 常规: 使用缓存, 缓存技术在很多时候能很好的解决数据库查询慢的问题.(redis等等). 不要使用select *，只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量;(以下示例为了简洁, 大量使用了select *, 实际项目中尽量避免) 排序优化:1).一般的获取分页数据,数据集较小,文件排序也很快; 但是对于类似一次按照顺序导出大量数据的时候,数据集很大,文件排序就会很慢,得让排序用上索引;order by在使用索引的时候同样要遵守最左前缀原则;需要所有排序列的排序方向一致(都为正序或都为倒序);连表查询时,order by的字段需要都是第一个表的才能命中索引;2).避免limit 的 offset值过大.select * from test_table where sex = ‘M’ order by rating limit 1000000,10;无论如何优化索引,这个查询都将很慢,因为随着偏移量的增加,mysql需要扫描大量需要丢弃的数据;可以通过限制用户能够翻页的数据量来避免该问题,一般也没用户在意搜索结果的上千页; 延迟关联 : 优化这类索引的另一个比较好的策略是使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这类逐渐关联原来获取得需要的行。这就可以减少MySQL扫描那些需要丢弃的行数。下面这个查询显示了如何高效的使用（sex rating）索引进行排序和分页： 123456789mysql&gt; SELECT &lt;cols&gt; FROM profiles INNER JOIN( -&gt; SELECT &lt;primary key cols&gt; FROM profiles -&gt; WHERE x.sex = 'M' ORDER BY rating LIMIT 100000,10 -&gt; ) AS x USING(&lt;primary key cols&gt;);上面语句优化的结果：mysql&gt; SELECT &lt;cols&gt; FROM profiles INNER JOIN( -&gt; SELECT id FROM profiles -&gt; WHERE x.sex = 'M' ORDER BY rating LIMIT 100000,10 -&gt; ) AS x WHERE x.id = profiles.id; 3).如果不是因为每次要获取相同条目的数据使用分页limit和offset; 而是因为想分批次处理完一批数据集(避免一次加载到内存中),而使用limit和offset,可以使用between and来避免offset的性能问题;例如: 给平台满足条件的用户(假如有很多,50万)发送消息;常见的方式是脚本for循环用户表select from user_tab where … limit 10000, 500;每次取500个满足条件的用户,直打取完;这样这个循环到了后面offset的值会非常的大,造成性能问题;推荐:使用between and循环取区间数据集的方法 来代替上面的limit offset;具体实现如下:要求用户id是自增的; 查询最小的用户id 和 最大的用户id, 每次批量处理一部分, 使用 between and 来查找用户id; 123456789101112131415161718$minUserId = User::where('create_time', '&lt;=', $endTime)-&gt;where('delete', 0)-&gt;min('user_id');$maxUserId = User::where('create_time', '&lt;=', $endTime)-&gt;where('delete', 0)-&gt;max('user_id');$studyReportModel = new MonthlyStudyReport();for ($start = $minUserId; $start &lt;= $maxUserId; $start += $pageSize + 1) &#123; $end = ($start + $pageSize) &gt; $maxUserId ? $maxUserId : $start + $pageSize; $msg = 'GenerateMonthlyStudyReport本次处理的用户id区间起始: ' . $start . " 结束为" . $end; $this-&gt;output-&gt;info($msg); Log4dd::info($msg); $userIds = User::where('user_id', 'between', [$start, $end])-&gt;where('create_time', '&lt;=', $endTime)-&gt;where('delete', 0)-&gt;column('user_id'); !empty($userIds) &amp;&amp; $this-&gt;sendMessage($userIds);//如果查到这个between and范围内的数据不为空,则对这些用户执行消息发送; 使用between and区间查询,因为后面还有where附加条件,所以这个区间里不满足条件的用户一样会被过滤掉; //虽然每次获取到的数据集条目不一定是500个(筛选后可能小于500), 但是并不影响我们最终给所有满足条件的用户发送了消息; 而且避开了limit offset过大的性能问题; $msg = 'GenerateMonthlyStudyReport该批次处理完'; Log4dd::info($msg); $this-&gt;output-&gt;info($msg); &#125; 允许为null的列，查询有潜在大坑:SELECT * FROM test_table where name != ‘tom’;该查询结果集中将不包括name is null 的情况;建议:设计表是字段尽量用not null约束以及给默认值。 如果明确知道只有一条结果返回，limit 1能够提高效率例如你里系统用户不允许一个邮箱注册多个账号,即一个邮箱在用户表里只会有一条有效记录.select * from user where email=’123456@qq.com’;可以优化为：select * from user where email=’123456@qq.com’ limit 1;原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动 分解大连接查询连表查询虽然能让我们更方便的拿到想要的数据, 但应该避免多个大表的连接查询, 连表过多会导致查询慢(特表是很多大表连接,且无法很好的用索引优化到查询时);可以先查出主要的数据结果集, 然后利用结果集中的关联字段去对应表中查询到关联结果集,再用程序将关联结果集聚合到总的数据结果集中;或者先查出小表的数据集,然后用这个数据集join大表; 防止sql注入, 类似laravel中如果写原生的raw查询等,参数使用绑定的方式,而不要直接写死到语句中; 事务最小化原则 死锁的预防; or查询转union 123456SELECT field1_index, field2_index FROM test_table WHERE field1_index = '1' OR field2_index = '1'; 如果field1_index, field2_index上建有索引 这种or查询将导致使用不了索引,可以修改为以下使用UNION:SELECT field1_index, field2_index FROM test_table WHERE field1_index = '1' UNIONSELECT field1_index, field2_index FROM test_table WHERE field2_index = '1'; 连接查询时,大表转小表,然后再连接: 123456789101112131415161718192021222324252627282930313233343536(1).where条件放在on内外的区别(特别是外连接查询时):mysql&gt; SELECT * FROM `t1`;+----+------+---------------------+| id | name | deleted_at |+----+------+---------------------+| 1 | 小明 | 2019-08-27 15:40:30 || 2 | 小天 | NULL |+----+------+---------------------+2 rows in set (0.05 sec)mysql&gt; SELECT * FROM `t2`;+----+-----+---------------------+| id | age | deleted_at |+----+-----+---------------------+| 2 | 25 | 2019-08-27 15:41:41 |+----+-----+---------------------+1 row in set (0.04 sec)mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id AND t2.deleted_at IS NULL WHERE t1.deleted_at IS NULL;+----+------+------------+------+------+------------+| id | name | deleted_at | id | age | deleted_at |+----+------+------------+------+------+------------+| 2 | 小天 | NULL | NULL | NULL | NULL |+----+------+------------+------+------+------------+1 row in set (0.04 sec)-- 条件跟在ON条件里面,先筛选t2表的记录，然后根据t1表返回t1表所有行mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t1.deleted_at IS NULL AND t2.deleted_at IS NULL;Empty set-- 条件在外面，先根据t1表返回所有记录，然后根据t2表条件删除记录(2).利用关联表的where写在on里面可以减小关联表的数据量来优化内连接join查询:select * from a json b on b.a_id = a.id where b.field1 = 100;-- 可改为select * from a json b on b.a_id = a.id and b.field1 = 100; 索引:索引对于良好的性能非常关键,尤其是在表数据量大时; 索引可以先简单理解为书的目录,可以帮你快速定位你想看的内容所在的页码;索引类型:PRIMARY key 主键, normal 一般、unique 唯一、full text 全文 特别说明:当查询需要访问大多数行时，顺序读取比通过索引更快。顺序读取可以最大限度地减少磁盘搜索，即使查询不需要所有行也是如此。mysql优化器会基于其他因素,如表大小、行数、I/O块大小来决定是使用索引还是表扫描.一般对于非常小的表 或者 对于大表的大部分数据量的查询(最佳索引跨越表的30%以上), 查询将进行全表扫描; 123-- 例如你在user表中查询sex='男'的记录;sex列建有索引, 但sex='男'的记录占总数据量的50%时;EXPLAIN SELECT * FROM `user` where `sex`='男';-- 你将看到查询分析的 possible_keys=sex,但是type=ALL,key=Null , 这说明实际并没走索引,而是进行的全表扫描; 所以在测试下面索引的用法时: 如果发现没有按照你的预期,出现了全表扫描, 请先看下是否是小表或者大表查询超过数据量的30%导致的; 索引优化常见注意事项: 查询经常用到的高频字段,用来连表的关联字段 最好建立上索引; 前导模糊查询不能命中索引;例如: select * from test_table where name like ‘%XX’; 无法使用索引而非前导模糊查询则可以：select * from test_table where name like ‘XX%’; 负向条件查询不能命中索引select * from test_table where age != 30;包括 not in等;not in/not exists都不是好习惯;(not exists比not in 好 , not exists可以走索引,避免不了负向查询就尽量用exists或者not exists); 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。explain select * from test_table where YEAR(date) &lt; ‘2019’;即使date列有索引, 改查询也将无法命中索引;类似的还有下面的这种神操作:EXPLAIN SELECT * FROM user where age+1 = 49; 无法命中age索引;233333计算尽量放到业务层完成,而非数据库层 B-Tree索引中,复合索引(多列索引)最左前缀原则:(说明:该项适用与B-Tree索引;哈希和其他类型的索引并不会像B-Tree一样按照顺序存储)即索引key(field1, field2, field3),要想很好利用该索引,需要你的查询语句能使用到靠左的字段,将索引中从左起到右的字段 部分/全部 使用到查询语句中;例如: 12345678910111213141516171819202122232425262728293031323334353637CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `gender` tinyint(4) NOT NULL DEFAULT '1' COMMENT '1代表男,2代表女', `age` tinyint(4) NOT NULL, `country` varchar(255) NOT NULL, `work` varchar(255) NOT NULL, PRIMARY KEY (`id`), KEY `user_composite_index` (`country`,`work`,`age`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;-- (1).可以很好用到索引user_composite_index的情况EXPLAIN SELECT * FROM `user` WHERE `country`='EN';EXPLAIN SELECT * FROM `user` WHERE `country`='EN' AND `work`='IT';EXPLAIN SELECT * FROM `user` WHERE `country`='EN' AND `work`='IT' ORDER BY `age` desc; -- sql语句中的写法顺序没有关系,如下也可 EXPLAIN SELECT * FROM `user` WHERE age=50 AND `country`='EN' AND `work`='IT';-- (2).完全无法使用索引user_composite_index的情况EXPLAIN SELECT * FROM `user` WHERE `work`='IT';EXPLAIN SELECT * FROM `user` WHERE `age` = 50;EXPLAIN SELECT * FROM `user` WHERE `work`='IT' ORDER BY `age` desc;EXPLAIN SELECT * FROM `user` WHERE `country`!='EN' AND `work`='IT' ORDER BY `age` desc;-- (3).部分使用到索引的情况explain SELECT * FROM `user` WHERE `country`='EN' AND `age`=50;explain SELECT * FROM `user` WHERE `country`='EN' AND `work`!='IT' AND `age`=50;+----+-------------+-------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | user | NULL | range | user_composite_index | user_composite_index | 1534 | NULL | 2 | 14.29 | Using index condition |+----+-------------+-------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+通过查看执行计划filtered,这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。 此处不为100%; 因为`work`使用了不等于,负向查询导致`work`没使用到索引; 后面的`age`因为在其左的`work`没命中索引,也将无法命中索引. 所以，在创建复合索引时，要根据业务需求，where子句中查询使用最频繁的一列放在索引最左边。 对于范围条件查询,Mysql无法再使用范围列后面的其他索引了,但对于”多个等值条件查询”则没有这个限制; 123456789101112131415161718192021222324CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `age` tinyint(4) NOT NULL, `work` varchar(255) NOT NULL, PRIMARY KEY (`id`), KEY `age_work` (`age`,`work`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;mysql&gt; EXPLAIN SELECT * FROM `user` where age in (70,75) and `work`='DOCTOR';+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | user | NULL | range | age_work | age_work | 768 | NULL | 2 | 100 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+1 row in setmysql&gt; mysql&gt; EXPLAIN SELECT * FROM `user` where age &gt;=70 and `work`='DOCTOR';+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | user | NULL | range | age_work | age_work | 768 | NULL | 12 | 10 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+1 row in set通过查看filtered是否为100%来判断多列索引的利用情况 索引列的顺序让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 123456789SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment;-- 结果: staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 强制类型转换会全表扫描例如: 1234567891011121314151617181920212223242526272829-- 商品表中serial_number 类型为varchar(15),该列添加的有索引CREATE TABLE `goods` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `serial_number` varchar(15) NOT NULL, PRIMARY KEY (`id`), KEY `serial_number` (`serial_number`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- 使用字符串时,查询使用到了索引mysql&gt; desc SELECT * FROM `goods` where serial_number='123456';+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+| 1 | SIMPLE | goods | NULL | ref | serial_number | serial_number | 47 | const | 1 | 100 | NULL |+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+1 row in set-- 使用int类型去强制转换时,查询未使用到索引, type为all,说明全表扫描了mysql&gt; mysql&gt; desc SELECT * FROM `goods` where serial_number=123456;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | goods | NULL | ALL | serial_number | NULL | NULL | NULL | 4 | 25 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in setmysql&gt; 覆盖查询:仅使用索引树中的信息从表中检索列信息，而不必执行额外的搜索以读取实际行。即索引包含所有需要查询的字段的值。具有以下优点： 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。 一个索引的题目:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `x` int(11) NOT NULL, `y` int(11) NOT NULL, `z` int(11) NOT NULL, `w` int(11) NOT NULL, PRIMARY KEY (`id`), KEY `x_y_z` (`x`,`y`,`z`)) ENGINE=InnoDB AUTO_INCREMENT=2038 DEFAULT CHARSET=utf8;-- 题目: 数据表如上, 下面哪些查询能用到索引x_y_z--(1) select * from t where where x=2002 and y=22 and z = 20; --用到索引x_y_z, 整个全用 --(2) select * from t where where x=2002 and y=22 and z like '%2'; --只使用到了索引x_y部分 --(3) select * from t where where x=2002 and y=22 and z like '2%'; --只使用到了索引x_y部分; 如果z字段为字符串类型(如varchar),则整个x_y_z都可以使用上; --(4) select * from t where where x&gt;=2002 and y=22 and z = 20; --只使用到了索引x部分 --(5) select * from t where where x=2002 and y&gt;22 and z = 20; --只使用到了索引x_y部分 --(6) select * from t where where x=2002 and y=22 order by z; --用到索引x_y_z, 整个全用 mysql&gt; EXPLAIN SELECT * FROM `t` where x=2002 and y=22 order by z;+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+-----------------------+| 1 | SIMPLE | t | NULL | ref | x_y_z | x_y_z | 8 | const,const | 11 | 100.00 | Using index condition |+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+-----------------------+1 row in set (0.05 sec)--(7) select * from t where where x=2002 order by y,z; -- 用到索引x_y_z, 整个全用 mysql&gt; EXPLAIN SELECT * FROM `t` where x=2002 order by y,z;+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+| 1 | SIMPLE | t | NULL | ref | x_y_z | x_y_z | 4 | const | 72 | 100.00 | Using index condition |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+1 row in set (0.04 sec)--(8) select * from t where where x=2002 order by z,y; -- 只使用到了索引x部分; 因为排序中的顺序是z,y没有遵守左前缀 mysql&gt; EXPLAIN SELECT * FROM `t` where x=2002 order by z,y;+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+---------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+---------------------------------------+| 1 | SIMPLE | t | NULL | ref | x_y_z | x_y_z | 4 | const | 72 | 100.00 | Using index condition; Using filesort |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+---------------------------------------+1 row in set (0.06 sec)-- 可以看到 Extra 中出现了 Using filesort--(9) select * from t where where x=2002 order by y asc, z desc; -- 只使用到了索引x_y部分; 因为排序中的y,z反向不一致, 一个正序, 一个倒序;mysql&gt; explain select * from t where x=2002 order by y asc;+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+| 1 | SIMPLE | t | NULL | ref | x_y_z | x_y_z | 4 | const | 72 | 100.00 | Using index condition |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+1 row in set (0.08 sec)-- mysql&gt; explain select * from t where x=2002 order by y asc, z desc;+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+---------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+---------------------------------------+| 1 | SIMPLE | t | NULL | ref | x_y_z | x_y_z | 4 | const | 72 | 100.00 | Using index condition; Using filesort |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+---------------------------------------+1 row in set (0.08 sec)-- 可以看到 Extra 中出现了 Using filesort--(10) select * from t where where x=2002 and y=22 order by z,w; --只使用到索引x_y部分; 因为排序中还有额外的一列w不在索引中;mysql&gt; EXPLAIN SELECT * FROM `t` where x=2002 and y=22 order by z,w;+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+---------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+---------------------------------------+| 1 | SIMPLE | t | NULL | ref | x_y_z | x_y_z | 8 | const,const | 11 | 100.00 | Using index condition; Using filesort |+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+---------------------------------------+1 row in set (0.04 sec)-- 可以看到 Extra 中出现了 Using filesort--(11) EXPLAIN SELECT z FROM `t` where x=2002 and y=22 group by z; --用到索引x_y_z, 整个全用 mysql&gt; EXPLAIN SELECT z FROM `t` where x=2002 and y=22 group by z;+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+--------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+--------------------------+| 1 | SIMPLE | t | NULL | ref | x_y_z | x_y_z | 8 | const,const | 11 | 100.00 | Using where; Using index |+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+--------------------------+1 row in set (0.07 sec)--(12) EXPLAIN SELECT z FROM `t` where x=2002 and y=22 group by z; --用到索引x_y_z, 整个全用 mysql&gt; EXPLAIN SELECT z FROM `t` where x=2002 and y=22 group by z;+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+--------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+--------------------------+| 1 | SIMPLE | t | NULL | ref | x_y_z | x_y_z | 8 | const,const | 11 | 100.00 | Using where; Using index |+----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+--------------------------+1 row in set (0.07 sec)--(13) SELECT z FROM `t` where x=2002 and y&gt;22 group by z; -- 只用到了索引x_y部分mysql&gt; EXPLAIN SELECT z FROM `t` where x=2002 and y&gt;22 group by z; +----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-------------------------------------------+| 1 | SIMPLE | t | NULL | range | x_y_z | x_y_z | 8 | NULL | 8 | 100.00 | Using where; Using index; Using temporary |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-------------------------------------------+1 row in set (0.08 sec)-- 可以看到 Extra 中出现了 Using temporary 库表结构设计优化及其他 选择合适的存储引擎:建表时就考虑选择存储引擎，如果是新闻之类的数据，由于插入和查询需求大，就选择myasim (Myisam：表锁，全文索引) ; 如果是电商中的数据,由于要用到事务和行锁,选择innodb ( innodb行(记录)锁，事务（回滚），外键. 事务安全型存储引擎，更加注重数据的完整性和安全性。) Memory：内存存储引擎，速度快、数据容易丢失 表结构设计:使用最小的字段通常更好,例如:固定长度的可以用char，类似md5()的密码;避免null;记得默认值,commit;建立恰当的索引;id自增，AUTO_INCREMENT标记类型的type/is_delete等可以用tinyint；bitmap; 缓存mysql服务自身提供的有缓存系统,可以开启缓存;但建议使用redis/memcached 分区基本概念，把一个表，从逻辑上分成多个区域，便于存储数据。采用分区的前提，数据量非常大。如果数据表的记录非常多，比如达到上亿条，数据表的活性就大大降低，数据表的运行速度就比较慢、效率低下，影响mysql数据库的整体性能，就可以采用分区解决，分区是mysql本身就支持的技术 分表水平拆分：是把一个表的全部记录信息分别存储到不同的分表之中。程序需要注意的是从哪个表读入,向哪个表更新; 垂直拆分：是把一个表的全部字段分别存储到不同的表里边。 分表方式: 方式一: 常规的关联id取模100来分表, 改方式较老旧, 不在一个子表的关联聚合等查询比较困难; 方式二: 使用mycat等工具; 清理数据碎片读写分离]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql使用小技巧]]></title>
    <url>%2F2018%2F08%2F10%2Fmysql%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[开篇:mysql的书写顺序: 123456select *columns* from *tables* where *predicae1* group by *columns* having *predicae1* order by *columns* limit *start*, *offset*; 但是mysql的查询执行顺序并不是按照书写顺序来的,而是按照如下的执行顺序: 1234567from *tables*where *predicae1*group by *columns*having *predicae1*select *columns*order by *columns*limit *start*, *offset*; 1.多个值的 IN 匹配语法: (字段1, 字段2) IN ( (字段1的结果1, 字段2的结果1), (字段1的结果2, 字段2的结果2) )语法示例: select * from table where (field1, field2) in ( (field1_value,field2_value) , (field1_value, field2_value), (field1_value, field2_value) );完整举例: 123456789101112131415161718192021222324252627-- ------------------------------ Table structure for Employee-- ----------------------------DROP TABLE IF EXISTS `Employee`;CREATE TABLE `Employee` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Name` varchar(255) NOT NULL, `Salary` int(11) NOT NULL, `DepartmentId` int(11) NOT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- ------------------------------ Records of Employee-- ----------------------------INSERT INTO `Employee` VALUES ('1', 'Joe', '70000', '1');INSERT INTO `Employee` VALUES ('2', 'Henry', '80000', '2');INSERT INTO `Employee` VALUES ('3', 'Sam', '60000', '2');INSERT INTO `Employee` VALUES ('4', 'Max', '90000', '1');INSERT INTO `Employee` VALUES ('5', 'Tom', '90000', '1');-- 查询语句:SELECT `Name` , `Salary`, `DepartmentId` FROM `Employee` where (Salary,DepartmentId) in((90000,1), (80000,2));-- 等价于: SELECT `Name` , `Salary`, `DepartmentId` FROM `Employee` where (`DepartmentId`, `Salary`) in (SELECT `DepartmentId`,MAX(`Salary`) as Salary FROM `Employee` GROUP BY `DepartmentId`); 2.字段加密常见的:SELECT MD5(‘123’);SELECT SHA(‘123’);SELECT PASSWORD(‘123’);MD5()：计算字符串的MD5校验和SHA：计算字符串的SHA校验和PASSWORD()：创建一个经过加密的密码字符串，适合于插入到MySQL的安全系统。该加密过程不可逆，和unix密码加密过程使用不同的算法。主要用于MySQL的认证系统。加密函数非常之多,官网:https://dev.mysql.com/doc/refman/8.0/en/encryption-functions.html 2.1 AES_ENCRYPT 和 AES_DECRYPT (推荐)使用AES算法解密/加密其加密的结果最好使用blob类型存储;语法: AES_ENCRYPT(‘要加密的值’, ‘token key’) AES_DECRYPT(‘被加密的字段’, ‘token key’) 123456789101112131415161718192021222324252627282930313233343536CREATE TABLE `encrypt` ( `id` int(11) NOT NULL AUTO_INCREMENT, `email` varchar(255) NOT NULL, `email_e` varbinary(255) DEFAULT NULL, `phone` varchar(255) NOT NULL, `phone_e` varbinary(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- 首先设置用来加密的key值, 该变量在以下语句中使用SET @key = 'D7DF5B64DF1181EF1D62D646A13AA860';-- (1)-- 添加完整的数据, email_e和phone_e使用AES_ENCRYPT('value',key)加密INSERT INTO `encrypt` (id,email,email_e,phone,phone_e) VALUES (1,'123456@qq.com', AES_ENCRYPT('123456@qq.com', @key), '12345678901', AES_ENCRYPT('12345678901', @key));-- 使用 AES_DECRYPT(field, key)来解密,查询 SELECT *,AES_DECRYPT(email_e, @key) as eamil_value,AES_DECRYPT(phone_e, @key) as phone_value FROM `encrypt` where id=1;-- 查询结果 +----+---------------+----------------+-------------+----------------+---------------+-------------+| id | email | email_e | phone | phone_e | eamil_value | phone_value |+----+---------------+----------------+-------------+----------------+---------------+-------------+| 1 | 123456@qq.com | 一些乱码 | 12345678901 | 一些乱码 | 123456@qq.com | 12345678901 |+----+---------------+----------------+-------------+----------------+---------------+-------------+-- (2)-- 你还可以对key再次的转变一次, 例如使用UNHEX, 即AES_ENCRYPT('value',UNHEX(key))加密INSERT INTO `encrypt` (id,email,phone) VALUES (2,'test@qq.com', '55555555555');UPDATE `encrypt` set `email_e`= AES_ENCRYPT(`email`, UNHEX(@key)),`phone_e`= AES_ENCRYPT(`phone`, UNHEX(@key)) WHERE id =2;-- 对应的查询SELECT *,AES_DECRYPT(email_e, UNHEX(@key)) as eamil_value,AES_DECRYPT(phone_e, UNHEX(@key)) as phone_value FROM `encrypt` where id=2;-- 查询结果+----+-------------+-----------------+-------------+----------------+-------------+-------------+| id | email | email_e | phone | phone_e | eamil_value | phone_value |+----+-------------+-----------------+-------------+----------------+-------------+-------------+| 2 | test@qq.com | 一些乱码 | 55555555555 | 一些乱码 | test@qq.com | 55555555555 |+----+-------------+-----------------+-------------+----------------+-------------+-------------+ 注: 上面的sql查询中的email_e和phone_e原来的乱码会影响到本博客hexo-next的搜索功能加载不了,故用正常字符描述…tips: php 的composer库 phpseclib/phpseclib 可以用来处理PKCS＃1（v2.1）RSA，DES，3DES，RC4，Rijndael，AES，Blowfish，Twofish，SSH-1，SSH-2， SFTP和X.509故mysql的AES_ENCRYPT可以和php的这个库结合使用 2.2 ENCODE() 和 DECODE()ENCODE(‘需要编码字符串’, ‘token key’)DECODE(‘被编码的字段’, ‘token key’)该函数有两个参数：被加密或解密的字符串和作为加密或解密基础的密钥。Encode结果是一个二进制字符串，以BLOB类型存储。加密程度相对比较弱 123456-- 表结构同上SET @key = 'D7DF5B64DF1181EF1D62D646A13AA860';INSERT INTO `encrypt` (id,email,email_e,phone,phone_e) VALUES (5,'new@qq.com', ENCODE('new@qq.com', @key), '000000', ENCODE('000000', @key));SELECT *,DECODE(email_e, @key) as eamil_value,DECODE(phone_e, @key) as phone_value FROM `encrypt` where id=5; 3.case when的使用3.1 case when 用于查询:这里介绍三种使用方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `gender` tinyint(4) NOT NULL DEFAULT '1' COMMENT '1代表男,2代表女', `age` tinyint(4) NOT NULL, `country` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES ('1', '小明', '1', '20', '中国');INSERT INTO `user` VALUES ('2', 'Tom', '1', '18', 'USA');INSERT INTO `user` VALUES ('3', 'Sam', '2', '50', 'USA');INSERT INTO `user` VALUES ('4', '小华', '2', '22', '中国');INSERT INTO `user` VALUES ('5', '老张', '1', '70', '中国');INSERT INTO `user` VALUES ('6', 'Joe', '1', '75', 'USA');-- (1). CASE 字段1 WHEN 具体的值(不可为某个范围匹配) THEN 'value' ELSE 'valus' AS 字段别名,-- CASE 字段2 WHEN 具体的值 THEN 'value' ELSE 'value' AS 字段别名,SELECT *,CASE `country` WHEN '中国' THEN '龙的传入' ELSE '外国人' END AS '背景',CASE `gender` WHEN '1' THEN '男' ELSE '女' END AS '性别'FROM `user`;-- query result:+----+------+--------+-----+---------+----------+------+| id | name | gender | age | country | 背景 | 性别 |+----+------+--------+-----+---------+----------+------+| 1 | 小明 | 1 | 20 | 中国 | 龙的传入 | 男 || 2 | Tom | 1 | 18 | USA | 外国人 | 男 || 3 | Sam | 2 | 50 | USA | 外国人 | 女 || 4 | 小华 | 2 | 22 | 中国 | 龙的传入 | 女 || 5 | 老张 | 1 | 70 | 中国 | 龙的传入 | 男 || 6 | Joe | 1 | 75 | USA | 外国人 | 男 |+----+------+--------+-----+---------+----------+------+-- (2).CASE WHEN 单个字段 这个可以对字段进行取范围,也可具体值SELECT *, CASE WHEN `age` &lt; 30 THEN '青年'WHEN `age` BETWEEN 30 and 50 THEN '中年' WHEN `age` = 70 THEN '古稀' ELSE '老年' END AS '年龄'FROM `user`;-- query result:+----+------+--------+-----+---------+------+| id | name | gender | age | country | 年龄 |+----+------+--------+-----+---------+------+| 1 | 小明 | 1 | 20 | 中国 | 青年 || 2 | Tom | 1 | 18 | USA | 青年 || 3 | Sam | 2 | 50 | USA | 中年 || 4 | 小华 | 2 | 22 | 中国 | 青年 || 5 | 老张 | 1 | 70 | 中国 | 古稀 || 6 | Joe | 1 | 75 | USA | 老年 |+----+------+--------+-----+---------+------+-- (3)CASE WHEN 字段1,字段2，可以对多个字段进行替换SELECT *, CASE WHEN `age` &lt; 30 THEN '青年'WHEN `country` = '中国' THEN '龙的传入' ELSE '未知' END AS '备注'FROM `user`;-- query result:+----+------+--------+-----+---------+----------+| id | name | gender | age | country | 备注 |+----+------+--------+-----+---------+----------+| 1 | 小明 | 1 | 20 | 中国 | 青年 || 2 | Tom | 1 | 18 | USA | 青年 || 3 | Sam | 2 | 50 | USA | 未知 || 4 | 小华 | 2 | 22 | 中国 | 青年 || 5 | 老张 | 1 | 70 | 中国 | 龙的传入 || 6 | Joe | 1 | 75 | USA | 未知 |+----+------+--------+-----+---------+----------+ 3.2 case when 用于更新:12345678910111213141516171819202122232425-- (1).单个字段的更新示例:UPDATE `categories` SET `display_order` = CASE `id` WHEN 1 THEN 3 WHEN 2 THEN 4 WHEN 3 THEN 5 ELSE 0 ENDWHERE `id` IN (1,2,3)-- (2).多个字段的更新示例:UPDATE `categories` SET `author` = '小明', `update_time` = '2017-10-10', `display_order` = CASE `id` WHEN 1 THEN 3 WHEN 2 THEN 4 WHEN 3 THEN 5 ELSE 0 END, `title` = CASE `id` WHEN 1 THEN 'New Title 1' WHEN 2 THEN 'New Title 2' WHEN 3 THEN 'New Title 3' ELSE 'null' ENDWHERE `id` IN (1,2,3) 提醒: 在使用批量更新, 批量插入等方式的时候, 需要注意最终执行的sql语句的长度, 一般sql语句的长度默认最大 1M , 可通过mysql配置文件my.ini修改 max_allowed_packet(不推荐);建议: 在批量插入/更新时, 若担心语句过程, 可以将要添加或者更新的数据 分成 多个批次执行; 例如插入10000条数据, 可以每次插入2000条, 分五次执行; 4.给查询结果增加递增的序号列语法:select (@rowNO := @rowNo+1) AS rowno,其他字段 from (select @rowNO:=0) as temp, 查询的表….关于 := 说明 123456789101112131415161718192021222324252627282930313233Unlike =, the := operator is never interpreted as a comparison operator. This means you can use := in any valid SQL statement (not just in SET statements) to assign a value to a variable.``` 参考: https://dev.mysql.com/doc/refman/8.0/en/assignment-operators.html#operator_assign-value ### 4.1 示例: ```sql-- ------------------------------ Table structure for Scores-- ----------------------------DROP TABLE IF EXISTS `Scores`;CREATE TABLE `Scores` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Score` float(5,2) NOT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- ------------------------------ Records of Scores-- ----------------------------INSERT INTO `Scores` VALUES (&apos;1&apos;, &apos;3.50&apos;);INSERT INTO `Scores` VALUES (&apos;2&apos;, &apos;3.65&apos;);INSERT INTO `Scores` VALUES (&apos;3&apos;, &apos;4.00&apos;);INSERT INTO `Scores` VALUES (&apos;4&apos;, &apos;3.85&apos;);INSERT INTO `Scores` VALUES (&apos;5&apos;, &apos;4.00&apos;);INSERT INTO `Scores` VALUES (&apos;6&apos;, &apos;3.65&apos;);-- 查询select (@rowNO := @rowNo+1) AS rowno,Score from (select @rowNO:=0) as temp, `Scores` ORDER BY Score desc;-- group by的自增序号-- 错误:select (@rowNO := @rowNo+1) AS rowno,Score from (select @rowNO:=0) as temp, `Scores` GROUP BY Score ORDER BY Score desc;-- 正确:select (@rowNO := @rowNo+1) AS rowno,s.Score from (select @rowNO:=0) as temp, (SELECT * from `Scores` GROUP BY Score ORDER BY Score desc) as s; 4.2 leetcode的一个题:编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。 +—-+——-+| Id | Score |+—-+——-+| 1 | 3.50 || 2 | 3.65 || 3 | 4.00 || 4 | 3.85 || 5 | 4.00 || 6 | 3.65 |+—-+——-+例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）： +——-+——+| Score | Rank |+——-+——+| 4.00 | 1 || 4.00 | 1 || 3.85 | 2 || 3.65 | 3 || 3.65 | 3 || 3.50 | 4 |+——-+——+ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rank-scores著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题目分析:先group by order by 拿到分数从高到底的排名,增加排名序号; 然后用分数表left join 按照分数高低排名即可 1234567891011121314151617181920212223-- ------------------------------ Table structure for Scores-- ----------------------------DROP TABLE IF EXISTS `Scores`;CREATE TABLE `Scores` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Score` float(5,2) NOT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- ------------------------------ Records of Scores-- ----------------------------INSERT INTO `Scores` VALUES ('1', '3.50');INSERT INTO `Scores` VALUES ('2', '3.65');INSERT INTO `Scores` VALUES ('3', '4.00');INSERT INTO `Scores` VALUES ('4', '3.85');INSERT INTO `Scores` VALUES ('5', '4.00');INSERT INTO `Scores` VALUES ('6', '3.65');-- 最终查询语句:select m.`Score`,convert(r.rowno, UNSIGNED) as Rank from Scores as m LEFT JOIN (select (@rowNO:= @rowNo+1) AS rowno,s.Score from (SELECT * FROM `Scores` group by `Score` order by `Score` desc ) as s, (select @rowNO:=0) as temp) as r on m.`Score`=r.`Score` ORDER BY m.`Score` desc; 5.类型转换convert, 首字符排序5.1.语法说明:MySQL 的CAST()和CONVERT()函数可用来获取一个类型的值，并产生另一个类型的值。两者具体的语法如下：CAST(value as type);CONVERT(value, type);即: CAST(xxx AS 类型), CONVERT(xxx,类型)。例如: SELECT CONVERT(‘23.00’, SIGNED); 可以转换的类型是有限制的。这个类型可以是以下值其中的一个：二进制，同带binary前缀的效果 : BINARY字符型，可带参数 : CHAR()日期 : DATE时间: TIME日期时间型 : DATETIME浮点数 : DECIMAL整数 : SIGNED无符号整数 : UNSIGNED 5.2.以汉字首字符排序name字段按照汉字正序 , 以name开头第一个字符来排序,依次是空格 0-9 a-z 字符 ,汉字首字拼音的首字母按照a-z来排序;select DISTINCT name from your_table order by convert(name using gbk) asc limit 300; 6. union 和 union all 的区别union在进行表求并集后会去掉重复的元素，所以会对所产生的结果集进行排序运算，删除重复的记录再返回结果。union all则只是简单地将两个结果集合并后就返回结果。因此，如果返回的两个结果集中有重复的数据，那么返回的结果就会包含重复的数据。tips: 使用联合查询,想区分结果集中的数据来自哪一张表,可以在查询中增加一个标志 1SELECT id,name ,1 as from_table_name FROM `teacher` union select id,name,2 as from_table_name from `student`; 7.获取每个分组下的前N条数据示例:找出各单位薪资前三高的员工 1234567891011121314151617181920212223-- ------------------------------ Table structure for user_salary-- ----------------------------DROP TABLE IF EXISTS `user_salary`;CREATE TABLE `user_salary` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Name` varchar(255) NOT NULL, `Salary` int(11) NOT NULL COMMENT '薪水', `DepartmentId` int(11) NOT NULL COMMENT '部门id', PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 COMMENT='各部门员工薪资表';-- ------------------------------ Records of user_salary-- ----------------------------INSERT INTO `user_salary` VALUES ('1', 'one_1', '2000', '1');INSERT INTO `user_salary` VALUES ('2', 'two_1', '3000', '1');INSERT INTO `user_salary` VALUES ('3', 'three_1', '1000', '1');INSERT INTO `user_salary` VALUES ('4', 'four_1', '4000', '1');INSERT INTO `user_salary` VALUES ('5', 'one_2', '8000', '2');INSERT INTO `user_salary` VALUES ('6', 'two_2', '5000', '2');INSERT INTO `user_salary` VALUES ('7', 'three_2', '6000', '2');INSERT INTO `user_salary` VALUES ('8', 'four_2', '7000', '2'); 由于mysql执行的先后顺序导致了不能简单的使用group by + order by + limit 来完成该查询;(1).查询示例: 123456789101112131415mysql&gt; SELECT * FROM `user_salary` as a where 3&gt;(SELECT count(*) FROM `user_salary` as b where b.`DepartmentId`=a.`DepartmentId` and b.`salary` &gt; a.`salary`)ORDER BY a.DepartmentId asc,a.Salary desc;+----+---------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+---------+--------+--------------+| 4 | four_1 | 4000 | 1 || 2 | two_1 | 3000 | 1 || 1 | one_1 | 2000 | 1 || 5 | one_2 | 8000 | 2 || 8 | four_2 | 7000 | 2 || 7 | three_2 | 6000 | 2 |+----+---------+--------+--------------+6 rows in setmysql&gt; 说明:采用逆向思维。各部门薪资最高的前三位，也就是薪资比该条记录的薪资还高的不能超过三条记录，即同一部门中,比当前记录薪资高的数据count(*)&lt;3; (2).修改下,第一种满足的数据出现大于所需条目的情况 1234-- 像部门2增加数据INSERT INTO `young`.`user_salary` (`Id`, `Name`, `Salary`, `DepartmentId`) VALUES ('9', 'five_2', '8000', '2');INSERT INTO `young`.`user_salary` (`Id`, `Name`, `Salary`, `DepartmentId`) VALUES ('10', 'six_2', '8000', '2');INSERT INTO `young`.`user_salary` (`Id`, `Name`, `Salary`, `DepartmentId`) VALUES ('11', 'seven_2', '8000', '2'); 同样的查询语句看结果: 12345678910111213141516mysql&gt; SELECT * FROM `user_salary` as a where 3&gt;(SELECT count(*) FROM `user_salary` as b where b.`DepartmentId`=a.`DepartmentId` and b.`salary` &gt; a.`salary`)ORDER BY a.DepartmentId asc,a.Salary desc;+----+---------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+---------+--------+--------------+| 4 | four_1 | 4000 | 1 || 2 | two_1 | 3000 | 1 || 1 | one_1 | 2000 | 1 || 5 | one_2 | 8000 | 2 || 9 | five_2 | 8000 | 2 || 10 | six_2 | 8000 | 2 || 11 | seven_2 | 8000 | 2 |+----+---------+--------+--------------+7 rows in setmysql&gt; 说明:可以看到部门2出现了四条满足情况的数据,因为最高的8000有四条;(如果我们只需三条,可以拿到后按照我们想要的顺序排序,然后程序代码控制只取前三条)(3). 类似(2)这样的,如果是想要不同值的前三名最高薪资,可以使用去重COUNT(DISTINCT expr,[expr…]) 12345678910111213141516171819mysql&gt; SELECT * FROM `user_salary` as a where 3&gt;(SELECT count(DISTINCT b.`salary`) FROM `user_salary` as b where b.`DepartmentId`=a.`DepartmentId` and b.`salary` &gt; a.`salary`)ORDER BY a.DepartmentId asc,a.Salary desc;+----+---------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+---------+--------+--------------+| 4 | four_1 | 4000 | 1 || 2 | two_1 | 3000 | 1 || 1 | one_1 | 2000 | 1 || 5 | one_2 | 8000 | 2 || 9 | five_2 | 8000 | 2 || 10 | six_2 | 8000 | 2 || 11 | seven_2 | 8000 | 2 || 8 | four_2 | 7000 | 2 || 7 | three_2 | 6000 | 2 |+----+---------+--------+--------------+9 rows in setmysql&gt; 参考和题目来源leetcode:https://blog.csdn.net/wzy_1988/article/details/52871636https://leetcode-cn.com/problems/department-top-three-salaries/ 8.记录一个LeetCode的题目,对count的使用题目链接:https://leetcode-cn.com/problems/trips-and-users/题解:(1). ①查出每天符合情况的, ②然后查出每天总的数目; 将①和②进行连表得出最终结果: 123456789101112select total.Request_at as `Day`,if(round(complete.cnt/total.cnt, 2) &gt; 0, round(complete.cnt/total.cnt, 2), 0.00) as `Cancellation Rate` from (SELECT Request_at,count(*) as cnt FROM Users as u INNER JOIN Trips as t on u.Users_Id=t.Client_Idwhere u.Role='client' and u.Banned='No' and Request_at BETWEEN '2013-10-01' and '2013-10-03' GROUP BY Request_at) as totalLEFT JOIN (SELECT Request_at,count(*) as cnt FROM Users as u INNER JOIN Trips as t on u.Users_Id=t.Client_Idwhere u.Role='client' and u.Banned='No' and t.Status in ('cancelled_by_driver', 'cancelled_by_client')and Request_at BETWEEN '2013-10-01' and '2013-10-03' GROUP BY Request_at) as complete on total.Request_at = complete.Request_at; 很显然这些看起来很low(2).利用count(null) = 0来解决这个问题(参考题解里的大佬答案): 123456789101112131415select t.request_at Day, ( round(count(if(status != 'completed', status, null)) / count(status), 2) ) as 'Cancellation Rate'from Users u inner join Trips ton u.Users_id = t.Client_Idand u.banned != 'Yes'where t.Request_at BETWEEN '2013-10-01' and '2013-10-03' group by t.Request_at; 看起来容易理解多了;sql中NULL的更多说明参考https://www.infoq.cn/article/CKm0rLd6VZaSxj6iR1ib]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql死锁]]></title>
    <url>%2F2018%2F07%2F06%2Fmysql%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[mysql中的锁:在MySQL中的锁分两大类，一种是读锁，一种是写锁，读锁（read lock）也可以称为共享锁（shared lock），写锁（write lock）也通常称为排它锁（exclusive lock）。 读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取一个资源，且互不干扰。写锁则是排他的，就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。 (待补充: 锁力度,行锁,间隙锁等) 死锁: 死锁模拟表结构: 12345CREATE TABLE `test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; 事务一T1中: 12345678mysql&gt; START TRANSACTION;Query OK, 0 rows affectedmysql&gt; update `test` set `name`="T1" where `id`=1;Query OK, 1 row affectedRows matched: 1 Changed: 1 Warnings: 0mysql&gt; ​ 事务二T2中: 新的事务T2 12345678mysql&gt; START TRANSACTION;Query OK, 0 rows affectedmysql&gt; update `test` set `name`="T1" where `id`=3;Query OK, 1 row affectedRows matched: 1 Changed: 1 Warnings: 0mysql&gt; 事务T1: 事务T1也执行删除操作 12mysql&gt; update `test` set `name`=&quot;T1&quot; where `id`=3;---阻塞等待中,等待T2释放id=3记录的X锁 事务T2 123mysql&gt; update `test` set `name`=&quot;T2&quot; where `id`=1;1213 - Deadlock found when trying to get lock; try restarting transactionmysql&gt; 事务T2抛错, 事务T1继续执行: 123456mysql&gt; update `test` set `name`="T1" where `id`=3;Query OK, 1 row affectedRows matched: 1 Changed: 1 Warnings: 0mysql&gt; mysql&gt; commit;Query OK, 0 rows affected 发生死锁后，InnoDB会为对一个客户(此处为 事务T2)产生错误信息并释放锁。返回给客户的信息： 12Deadlock found when trying to get lock;try restarting transaction 所以，另一个客户(事务T1)可以正常执行任务。死锁结束。 日常注意:事务尽量简单化: 123456789101112131415 //各种其他可以不在事务中执行的操作,应该在事务外执行,例如其他的数据获取,数据处理,数据格式调整,其他耗时处理等等$this-&gt;beginTrans(); //在事务内, 尽量只集中处理事务该处理的sql部分 try &#123; $this-&gt;update(); //因为在事务中,处理这些,事务就会等待这些处理完了,再提交或者回滚,那样事务内的锁就会挂起太久, 容易导致死锁问题 $this-&gt;delete(); $this-&gt;commit(); &#125; catch (Exception $e) &#123; $this-&gt;rollBack(); throw new MessageException('操作失败', 0); &#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql优化之EXPLAIN]]></title>
    <url>%2F2018%2F04%2F05%2Fmysql%E4%BC%98%E5%8C%96%E4%B9%8BEXPLAIN%2F</url>
    <content type="text"><![CDATA[MySQL可以通过EXPLAIN或DESC来查看并分析SQL语句的执行情况;explain为mysql提供语句的执行计划信息。可以应用在 SELECT, DELETE, INSERT, REPLACE, UPDATE 语句上。explain的执行计划，只是作为语句执行过程的一个参考，实际执行的过程不一定和计划完全一致，但是执行计划中透露出的讯息却可以帮助选择更好的索引和写出更优化的查询语句。还可以使用 EXPLAIN检查优化程序是否以最佳顺序连接表… EXPLAIN Output Format参考: https://dev.mysql.com/doc/refman/8.0/en/explain-output.html explain 会为select语句中用到的每一个表返回一行信息,EXPLAIN输出中的表,按照mysql在处理语句时读取的顺序列出; EXPLAIN Output Columns Column JSON Name Meaning id select_id The SELECT identifier select_type None The SELECT type table table_name The table for the output row partitions partitions The matching partitions type access_type The join type possible_keys possible_keys The possible indexes to choose key key The index actually chosen key_len key_length The length of the chosen key ref ref The columns compared to the index rows rows Estimate of rows to be examined filtered filtered Percentage of rows filtered by table condition Extra None Additional information 下面对表头的每一行进行解释说明: idselect 标识, select在查询时的序列号, 表示的是查询中执行select子句或者是操作表的顺序。说明:id相同表示加载表的顺序是从上到下。id不同id值越大，优先级越高，越先被执行。id有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。如果行引用其他行的联合结果，则该值可以为Null。在这种情况下，table列会显示一个类似于&lt; union m，n&gt;的值，以指示该行是explain输出表中select的id值为m和n行的并集。 示例: 12345678910111213141516mysql&gt; EXPLAINSELECT t1.name,(SELECT id from t2 where id=2) as id2 FROM `t1` LEFT JOIN t3 on t3.id=t1.idUNION(SELECT name,id from t2);+------+--------------+------------+------------+--------+---------------+---------+---------+----------------+------+----------+-----------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+------+--------------+------------+------------+--------+---------------+---------+---------+----------------+------+----------+-----------------+| 1 | PRIMARY | t1 | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 100 | NULL || 1 | PRIMARY | t3 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | leetcode.t1.id | 1 | 100 | Using index || 2 | SUBQUERY | t2 | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100 | Using index || 3 | UNION | t2 | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 100 | NULL || NULL | UNION RESULT | &lt;union1,3&gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary |+------+--------------+------------+------------+--------+---------------+---------+---------+----------------+------+----------+-----------------+ select的执行顺序依次为 3 -&gt; 2 -&gt; 1 (id=1第一行) -&gt; 1 (id=1的第二行) -&gt; NULL select_type查询的类型,类型如下表所示: select_type Value JSON Name Meaning SIMPLE None Simple SELECT (not using UNION or subqueries) PRIMARY None Outermost SELECT UNION None Second or later SELECT statement in a UNION DEPENDENT UNION dependent (true) Second or later SELECT statement in a UNION, dependent on outer query UNION RESULT union_result Result of a UNION. SUBQUERY None First SELECT in subquery DEPENDENT SUBQUERY dependent (true) First SELECT in subquery, dependent on outer query DERIVED None Derived table DEPENDENT DERIVED dependent (true) Derived table dependent on another table MATERIALIZED materialized_from_subquery Materialized subquery UNCACHEABLE SUBQUERY cacheable (false) A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query UNCACHEABLE UNION cacheable (false) The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) SIMPLE : 简单的查询,没有用到联合查询或者子查询 PRIMARY : 如果查询有任何复杂的子查询，则最外层标记为PRIMARY（比如说查询包含DERIVED、UNION、UNION RESUlT…这些, 则最外层的那个查询标记为 PRIMARY） UNION : union查询中的第二个或者最后语句; select … t1 UNION (select …. t2 ),此时第二个查询语句select_type会被标上union DEPENDENT UNION : 在UNION中第二个或最后的SELECT语句，同时该语句依赖外部的查询. UNION RESULT : 联合查询的结果 SUBQUERY : 子查询中的第一个select DEPENDENT SUBQUERY : DERIVED : 派生表. ( 参考:https://www.yiibai.com/mysql/derived-table.html ) DEPENDENT DERIVED : MATERIALIZED : UNCACHEABLE SUBQUERY : UNCACHEABLE UNION : 派生表set optimizer_switch=’derived_merge=off’;EXPLAIN SELECT name from (SELECT id,name from t1 ) as T;参考: https://www.cnblogs.com/ivictor/p/9281488.html TABLE输出行所引用的表的名称。这也可以是以下值之一： &lt; union M,N&gt; &lt; derived N&gt; &lt; subquery N&gt; partitions查询匹配到记录的分区。非分区表的该值为null。 typeEXPLAIN Join Types表示表的连接类型;下面来描述这些join type, 从最佳type到最差的顺序说明: system :表只有一行 (= system table) const :表最多有一个匹配行，该行在查询开始时读取。因为只有一行，所以优化器的其余部分可以将此行列中的值视为常量。const表非常快，因为它们只读一次。当你将PRIMARY KEY或 UNIQUE index与常量值进行比较时，使用就是const(如果是联合主键或联合唯一索引,需要将这个索引的所有组成部分都进行常量比较)。如下示例： 1234# 单一主键SELECT * FROM tbl_name WHERE primary_key=1;# 联合主键SELECT * FROM tbl_name WHERE primary_key_part1=1 AND primary_key_part2=2; eq_ref : (equal reference ?)只匹配到一行的时候。除了system和const之外，这是最好的连接类型了。当我们使用主键索引或者唯一索引的时候，(如果是联合主键或联合唯一索引,需要将这个索引的所有组成部分都用到),就会是该类型。(简单来说，就是多表连接中使用primary key或者 unique key作为关联条件)在对已经建立索引列(要保证每次只匹配一行,所以得是唯一索引)进行 = 操作的时候，eq_ref会被使用到。比较值可以使用一个常量也可以是一个表达式, 这个表达示可以是其他的表的行。 12345678910#. 多表关联查询，单行匹配SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column;-- 说明ref_table.key_column该行需有主键/唯一键,这样的话,最终对应的other_table.column在ref_table中最多只能匹配到一行 #. 多表关联查询，联合索引，多行匹配SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; ref :可以理解为要比较的 值/表达式/其他表的行, 对应的在该表中的索引字段上有多行与之匹配;(与eq_ref不同的是匹配到了多行, 所以这个索引不能是唯一索引);匹配到的记录越少,性能越好;ref可以用于使用 = 、or 、 &lt;=&gt; 运算符进行比较的索引列; 1234类似表A上有联合索引1 index_key1 ('country','age'); 单列索引2 index_key2 'email';select * from A where `country`='EN';select * from A where `email`='**';上面两个explain的type将为ref 示例: 1234567891011# 根据索引（非主键，非唯一索引），匹配到多行SELECT * FROM ref_table WHERE key_column=expr;# 多表关联查询，单个索引，多行匹配SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column;# 多表关联查询，联合索引，多行匹配SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; fulltext :使用全文索引的时候才会出现 ref_or_null :这个查询类型和ref很像，但是 MySQL 会做一个额外的查询，来看哪些行包含了NULL (这是因为mysql单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到”不符合预期”的结果集)。这种类型常见于解析子查询的优化。 12SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL; index_merge :参考: https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html unique_subquery :该类型替换了下面形式的IN子查询的eq_ref, 而且子查询是主键或者唯一索引 1value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery 只是一个索引查找功能，它可以完全替换子查询以提高效率。 index_subquery :类似 unique_subquery, 不同的是它在子查询里使用的是非唯一索引。 1value IN (SELECT key_column FROM single_table WHERE some_expr) range :范围查询,常见于 &gt;, &gt;=, &lt;, &lt;=, BETWEEN, LIKE, IN() index :index类型和ALL类型一样，区别就是index类型是扫描的索引树。以下两种情况会触发：如果索引是查询的覆盖索引，就是说索引查询的数据可以满足查询中所需的所有数据，则只扫描索引树，不需要回表查询。 在这种情况下，explain 的 Extra 列的结果是 Using index。仅索引扫描通常比ALL快，因为索引的大小通常小于表数据。全表扫描会按索引的顺序来查找数据行。使用索引不会出现在Extra列中。 ALL :全表扫描 (赶紧看看能不能加索引, 重写更优化的查询语句等方式来优化下) possible_keys显示查询时可能用到的索引 keyMySQL实际决定使用的索引 key_lenMySQL决定使用的索引的长度。该值使你可以确定MySQL实际使用了多列索引的多少部分; (在优化索引最左匹配原则的时候,你可以使用到) rows该rows列表示MySQL认为必须检查以执行查询的行数。(即扫描的行数)对于InnoDB表，此数字是估算值，可能并不总是准确的。 filtered旧版本mysql使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。 Extra此列包含有关MySQL如何解析查询的其他信息。常见情况: Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤 Using temporary：表示要解析查询，MySQL需要创建一个临时表来保存结果。常见于排序和分组查询 Using filesort：mysql需要一次额外的传递来完成排序;(即在当前查询中mysql无法直接利用索引排序,需要额外执行排序操作)例如: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182-- 课程周期表CREATE TABLE `uc_course` ( `id` int(1) unsigned NOT NULL AUTO_INCREMENT, `parent` int(1) unsigned NOT NULL DEFAULT '0' COMMENT '对应课程表中的课程id', `name` varchar(150) NOT NULL COMMENT '课程周期名称', `org_id` int(1) unsigned NOT NULL, PRIMARY KEY (`id`), KEY `org_id` (`org_id`), KEY `parent` (`parent`) USING BTREE, KEY `org_and_parent` (`org_id`,`parent`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- (1).可以直接使用索引排序的情况1:mysql&gt; EXPLAIN SELECT * FROM `uc_course` where parent in (28,744,1387,1441) ORDER BY parent desc;+----+-------------+-----------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-----------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | uc_course | NULL | range | parent | parent | 4 | NULL | 159 | 100 | Using index condition |+----+-------------+-----------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------+-- 可以发现该查询使用到的索引key=parent,就是我们order by的字段, 所以排序也能使用到该索引,Extra列没有出现Using filesort-- (2.1).不能直接使用索引排序的情况1:mysql&gt; EXPLAIN SELECT * FROM `uc_course` where org_id = 9 ORDER BY parent desc;+----+-------------+-----------+------------+------+---------------+--------+---------+-------+------+----------+---------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-----------+------------+------+---------------+--------+---------+-------+------+----------+---------------------------------------+| 1 | SIMPLE | uc_course | NULL | ref | org_id | org_id | 4 | const | 639 | 100 | Using index condition; Using filesort |+----+-------------+-----------+------------+------+---------------+--------+---------+-------+------+----------+---------------------------------------+-- 上面的查询计划我们可以看到Extra列出现了Using filesort, 这是为什么了,我们的parent列上明明有索引? -- 这是因为这里的查询语句中用到的索引key=org_id,没有用到排序字段parent,所以在查询到数据后,mysql还要额外操作一次来完成排序;即会出现 using filesort;-- (2.2).不能直接使用索引排序的情况2:mysql&gt; EXPLAIN SELECT * FROM `uc_course` where org_id = 9 and parent in (28,744,1387,1441) ORDER BY parent desc;+----+-------------+-----------+------------+------+---------------+--------+---------+-------+------+----------+----------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-----------+------------+------+---------------+--------+---------+-------+------+----------+----------------------------------------------------+| 1 | SIMPLE | uc_course | NULL | ref | org_id,parent | org_id | 4 | const | 639 | 22.3 | Using index condition; Using where; Using filesort |+----+-------------+-----------+------------+------+---------------+--------+---------+-------+------+----------+----------------------------------------------------+-- 这一次虽然我们在where中加上了对parent的条件查询,但是查询计划显示的最终我们使用的索引key只有org_id,还是没有用到parent,索引依旧出行了using firesort;-- (3). 如何避免(2)中出现的情况了?-- 添加复合索引: KEY `org_and_parent` (`org_id`,`parent`) USING BTREEmysql&gt; EXPLAIN SELECT * FROM `uc_course` where org_id = 9 ORDER BY parent desc;+----+-------------+-----------+------------+------+-----------------------+----------------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-----------+------------+------+-----------------------+----------------+---------+-------+------+----------+-------------+| 1 | SIMPLE | uc_course | NULL | ref | fk_org,org_and_parent | org_and_parent | 4 | const | 639 | 100 | Using where |+----+-------------+-----------+------------+------+-----------------------+----------------+---------+-------+------+----------+-------------+1 row in setmysql&gt; EXPLAIN SELECT * FROM `uc_course` where org_id = 9 and parent in (28,744,1387,1441) ORDER BY parent desc;+----+-------------+-----------+------------+-------+------------------------------+----------------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-----------+------------+-------+------------------------------+----------------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | uc_course | NULL | range | fk_org,parent,org_and_parent | org_and_parent | 8 | NULL | 141 | 100 | Using index condition |+----+-------------+-----------+------------+-------+------------------------------+----------------+---------+------+------+----------+-----------------------+-- 我们可以看到并没有再出现using filesort; 因为查询命中的索引key是org_and_parent,它是复合索引,包含了where中需要的org_id,也包括了order by用到的字段parent; -- (4).如果查询需要关联多张表,则只有当order by子句引用的字段**全部**为第一个表时,才能使用索引做排序;-- 该点具体参考: &lt;&lt;高性能mysql&gt;&gt;一书的5.3.7节-- 课程表结构:CREATE TABLE `uc_course_package` ( `id` int(1) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(150) NOT NULL COMMENT '课程名称',, PRIMARY KEY (`id`),) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- (4.1)当order by 字段来自第一张表时: 可利用索引排序mysql&gt; EXPLAIN SELECT * FROM `uc_course` as c LEFT JOIN uc_course_package as p on c.parent=p.id where parent in (28,744,1387,1441) ORDER BY c.parent desc;+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-----------------------+| 1 | SIMPLE | c | NULL | range | parent | parent | 4 | NULL | 159 | 100 | Using index condition || 1 | SIMPLE | p | NULL | eq_ref | PRIMARY | PRIMARY | 4 | uooc.c.parent | 1 | 100 | NULL |+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-----------------------+-- (4.2)当order by 字段来自后面的表时: 出现 using filesort mysql&gt; EXPLAIN SELECT * FROM uc_course_package as p LEFT JOIN `uc_course` as c on c.parent=p.id where parent in (28,744,1387,1441) ORDER BY c.parent desc;+----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------------+| 1 | SIMPLE | p | NULL | range | PRIMARY | PRIMARY | 4 | NULL | 4 | 100 | Using where; Using temporary; Using filesort || 1 | SIMPLE | c | NULL | ref | parent | parent | 4 | uooc.p.id | 1 | 100 | NULL |+----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+----------------------------------------------+ In some cases, MySQL cannot use indexes to resolve the ORDER BY, although it still uses indexes to find the rows that match the WHERE clause. These cases include the following: The key used to fetch the rows is not the same as the one used in the ORDER BY.参考: https://dev.mysql.com/doc/refman/5.5/en/order-by-optimization.html Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。 Impossible where：这个值强调了where语句会导致没有符合条件的行。 Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行 Using index : 索引覆盖查询 (仅使用索引树中的信息从表中检索列信息，而不必执行额外的搜索以读取实际行。)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
