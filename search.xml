<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql幻读]]></title>
    <url>%2F2019%2F07%2F05%2Fmysql%E5%B9%BB%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[事务隔离级别mysql 有四级事务隔离级别: (图来自: &lt;高性能mysql一书&gt;) 解释: 脏读: 在事务T1中可以读取到事务T2中还没提交的更新; 不可重复读: 事务T1能够读取到事务T2提交后的更新, 这将导致事务T1在T2提交前后读取到的数据不一样, 即不可重复读; 幻读: 幻读，并不是指在同一事务中执行两次同样的sql语句获取到的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。 幻读举例: 1.幻读的产生:下面用REPEATABLE-READ隔离级别举例说明 查看看事务隔离级别和测试表(innodb存储引擎的表)结构: 12345678910111213141516171819202122232425262728293031mysql&gt; select @@global.tx_isolation, @@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in setmysql&gt; mysql&gt; desc test;+-------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(255) | NO | | NULL | |+-------+--------------+------+-----+---------+----------------+2 rows in set (1). 事务T1中123456789mysql&gt; begin;Query OK, 0 rows affectedmysql&gt; select * from test where id =1;Empty setmysql&gt; (2). 事务T2:1234567891011121314151617181920212223242526272829mysql&gt; begin;Query OK, 0 rows affectedmysql&gt; select * from test where id =1;Empty setmysql&gt; insert into test values (1, &apos;first&apos;);Query OK, 1 row affectedmysql&gt; commit;Query OK, 0 rows affectedmysql&gt; select * from test where id =1;+----+-------+| id | name |+----+-------+| 1 | first |+----+-------+1 row in set (3). 回到事务T1中:12345678910111213mysql&gt; select * from test where id =1;Empty setmysql&gt; insert into test values(1, &apos;second&apos;);1062 - Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;mysql&gt; mysql&gt; select * from test where id =1;Empty set 我们可以看到在T2事务的中途干扰下, 导致T1事务出现了幻读 : 在事务T1中查询 id=1的数据不存在, 但指定id为1插入数据时又会抛出错误 Duplicate entry ‘1’ for key ‘PRIMARY’ , 然后我们在出现插入错误提示后, 在T1中查询id=1的数据还是不存在。 2.SERIALIZABLE防止幻读的方式因为在该隔离级别下, 会给读取到的每一条数据强制加锁 (数据行存在加 X锁, 不存在的加Gap Lock锁 ), 即记录存在与否，mysql 都会对记录应该对应的索引加锁，其他事务是无法再获得做操作的。 MySQL InnoDB支持三种行锁定方式： 行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key。 间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而已的。 Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php递归和引用实现的无限极分类]]></title>
    <url>%2F2018%2F07%2F12%2Fphp%E9%80%92%E5%BD%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[无限极分类类似省、市、区,构建成一个父级下面有多个子元素的数据结构;子元素与父元素之间通常使用id和parentId来关联; php递归实现无限极分类:该方法实现的无限极分类在数据量和子层级较多时,很慢,因为递归调用每次都要遍历大量的数据;代码示例: 1234567891011121314151617181920212223&lt;?phpfunction buildTreeByRecursion(array $elements, $rootValue = 0, $parentField = "parent", $index = '', $level = 0)&#123; $branch = array(); $level++; foreach ($elements as $k =&gt; $element) &#123; $element['_level'] = $level; if ($element[$parentField] == $rootValue) &#123; unset($elements[$k]);//减轻下次递归时遍历的数量 $children = buildTreeByRecursion($elements, $element['id'], $parentField, $index, $level); if ($children) &#123; $element['children'] = $children; &#125; if (empty($index)) &#123; $branch[] = $element; &#125; else &#123; $branch[$element[$index]] = $element; &#125; &#125; &#125; return $branch;&#125; php引用传值方式实现无限极分类首先我们看下简单php的引用传值: 12345678910111213141516171819&lt;?php$list = [ 0 =&gt; ['id' =&gt; 1,], 1 =&gt; ['id' =&gt; 2,], 2 =&gt; ['id' =&gt; 3,]];$tree = [ 0 =&gt; &amp;$list[0], 1 =&gt; &amp;$list[1], 2 =&gt; $list[2],];var_dump($tree);$list[0]['children'] = ['first new child'];$list[1]['children'] = ['second new child'];$list[2]['children'] = ['third new child'];var_dump($tree);exit(); php的应用传值是将变量对应的内存地址指向同一个地址,即$a = &amp;$b;那么修改$a或者$b的值,实际相当于修改的是他们在内存中的地址处的值, 那么两个变量的值都将变化,因为他们的地址指向的值变了; 地址引用无限极分类:该方法很快, 因为不用像递归那样多次遍历数据; 12345678910111213141516171819202122&lt;?phpfunction getTreeByQuote($list, $pid = 0, $parentField = 'parent')&#123; $tree = []; if (!empty($list)) &#123; //第一步 构造数据:修改为以id为下标的列表 $newList = []; foreach ($list as $k =&gt; $v) &#123; $newList[$v['id']] = $v; &#125; //第二步: 遍历数据,生成树状结构 foreach ($newList as $value) &#123; if ($pid == $value[$parentField]) &#123; $tree[] = &amp;$newList[$value['id']]; &#125; elseif (isset($newList[$value[$parentField]])) &#123; $newList[$value[$parentField]]['children'][] = &amp;$newList[$value['id']]; &#125; &#125; &#125; return $tree;&#125; 测试: 1234567891011121314151617181920&lt;?php/*** 前面的递归和引用实现无限极分类函数 */$data = file_get_contents('./category.json');$data = json_decode($data, true);$_base_time = time();$_base = memory_get_usage();//$res = buildTreeByRecursion($data, 0, 'parentId');$res = getTreeByQuote($data, 0, 'parentId');$_end_time = time();$_end = memory_get_usage();var_dump('内存使用'.(int)(($_end-$_base)/1024).'kb');var_dump('时间使用'.($_end_time-$_base_time).'s');var_dump($res);exit();echo json_encode($res, JSON_UNESCAPED_UNICODE);exit(); 测试数据: 4818条数据,其中一级44个,二级元素452个,三级元素4326个;递归方式,内存使用2082kb,时间使用11s;引用方式,内存使用608kb,时间使用0s;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql死锁]]></title>
    <url>%2F2018%2F07%2F06%2Fmysql%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[mysql中的锁:在MySQL中的锁分两大类，一种是读锁，一种是写锁，读锁（read lock）也可以称为共享锁（shared lock），写锁（write lock）也通常称为排它锁（exclusive lock）。 读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取一个资源，且互不干扰。写锁则是排他的，就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。 (待补充: 锁力度,行锁,间隙锁等) 死锁: 死锁模拟表结构: 12345CREATE TABLE `test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; 事务一T1中: 12345678mysql&gt; START TRANSACTION;Query OK, 0 rows affectedmysql&gt; update `test` set `name`="T1" where `id`=1;Query OK, 1 row affectedRows matched: 1 Changed: 1 Warnings: 0mysql&gt; ​ 事务二T2中: 新的事务T2 12345678mysql&gt; START TRANSACTION;Query OK, 0 rows affectedmysql&gt; update `test` set `name`="T1" where `id`=3;Query OK, 1 row affectedRows matched: 1 Changed: 1 Warnings: 0mysql&gt; 事务T1: 事务T1也执行删除操作 12mysql&gt; update `test` set `name`=&quot;T1&quot; where `id`=3;---阻塞等待中,等待T2释放id=3记录的X锁 事务T2 123mysql&gt; update `test` set `name`=&quot;T2&quot; where `id`=1;1213 - Deadlock found when trying to get lock; try restarting transactionmysql&gt; 事务T2抛错, 事务T1继续执行: 123456mysql&gt; update `test` set `name`="T1" where `id`=3;Query OK, 1 row affectedRows matched: 1 Changed: 1 Warnings: 0mysql&gt; mysql&gt; commit;Query OK, 0 rows affected 发生死锁后，InnoDB会为对一个客户(此处为 事务T2)产生错误信息并释放锁。返回给客户的信息： 12Deadlock found when trying to get lock;try restarting transaction 所以，另一个客户(事务T1)可以正常执行任务。死锁结束。 日常注意:事务尽量简单化: 123456789101112131415 //各种其他可以不在事务中执行的操作,应该在事务外执行,例如其他的数据获取,数据处理,数据格式调整,其他耗时处理等等$this-&gt;beginTrans(); //在事务内, 尽量只集中处理事务该处理的sql部分 try &#123; $this-&gt;update(); //因为在事务中,处理这些,事务就会等待这些处理完了,再提交或者回滚,那样事务内的锁就会挂起太久, 容易导致死锁问题 $this-&gt;delete(); $this-&gt;commit(); &#125; catch (Exception $e) &#123; $this-&gt;rollBack(); throw new MessageException('操作失败', 0); &#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql使用]]></title>
    <url>%2F2017%2F08%2F10%2Fmysql%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.多个值的 IN 匹配语法: (字段1, 字段2) IN ( (字段1的结果1, 字段2的结果1), (字段1的结果2, 字段2的结果2) )语法示例: select * from table where (field1, field2) in ( (field1_value,field2_value) , (field1_value, field2_value), (field1_value, field2_value) );完整举例: 123456789101112131415161718192021222324252627-- ------------------------------ Table structure for Employee-- ----------------------------DROP TABLE IF EXISTS `Employee`;CREATE TABLE `Employee` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Name` varchar(255) NOT NULL, `Salary` int(11) NOT NULL, `DepartmentId` int(11) NOT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- ------------------------------ Records of Employee-- ----------------------------INSERT INTO `Employee` VALUES ('1', 'Joe', '70000', '1');INSERT INTO `Employee` VALUES ('2', 'Henry', '80000', '2');INSERT INTO `Employee` VALUES ('3', 'Sam', '60000', '2');INSERT INTO `Employee` VALUES ('4', 'Max', '90000', '1');INSERT INTO `Employee` VALUES ('5', 'Tom', '90000', '1');-- 查询语句:SELECT `Name` , `Salary`, `DepartmentId` FROM `Employee` where (Salary,DepartmentId) in((90000,1), (80000,2));-- 等价于: SELECT `Name` , `Salary`, `DepartmentId` FROM `Employee` where (`DepartmentId`, `Salary`) in (SELECT `DepartmentId`,MAX(`Salary`) as Salary FROM `Employee` GROUP BY `DepartmentId`); 2.字段加密常见的:SELECT MD5(‘123’);SELECT SHA(‘123’);SELECT PASSWORD(‘123’);MD5()：计算字符串的MD5校验和SHA：计算字符串的SHA校验和PASSWORD()：创建一个经过加密的密码字符串，适合于插入到MySQL的安全系统。该加密过程不可逆，和unix密码加密过程使用不同的算法。主要用于MySQL的认证系统。加密函数非常之多,官网:https://dev.mysql.com/doc/refman/8.0/en/encryption-functions.html 2.1 AES_ENCRYPT 和 AES_DECRYPT (推荐)使用AES算法解密/加密其加密的结果最好使用blob类型存储;语法: AES_ENCRYPT(‘要加密的值’, ‘token key’) AES_DECRYPT(‘被加密的字段’, ‘token key’) 123456789101112131415161718192021222324252627282930313233343536CREATE TABLE `encrypt` ( `id` int(11) NOT NULL AUTO_INCREMENT, `email` varchar(255) NOT NULL, `email_e` varbinary(255) DEFAULT NULL, `phone` varchar(255) NOT NULL, `phone_e` varbinary(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- 首先设置用来加密的key值, 该变量在以下语句中使用SET @key = 'D7DF5B64DF1181EF1D62D646A13AA860';-- (1)-- 添加完整的数据, email_e和phone_e使用AES_ENCRYPT('value',key)加密INSERT INTO `encrypt` (id,email,email_e,phone,phone_e) VALUES (1,'123456@qq.com', AES_ENCRYPT('123456@qq.com', @key), '12345678901', AES_ENCRYPT('12345678901', @key));-- 使用 AES_DECRYPT(field, key)来解密,查询SELECT *,AES_DECRYPT(email_e, @key) as eamil_value,AES_DECRYPT(phone_e, @key) as phone_value FROM `encrypt` where id=1;-- 查询结果+----+---------------+----------------+-------------+----------------+---------------+-------------+| id | email | email_e | phone | phone_e | eamil_value | phone_value |+----+---------------+----------------+-------------+----------------+---------------+-------------+| 1 | 123456@qq.com | 一些乱码 | 12345678901 | 一些乱码 | 123456@qq.com | 12345678901 |+----+---------------+----------------+-------------+----------------+---------------+-------------+-- (2)-- 你还可以对key再次的转变一次, 例如使用UNHEX, 即AES_ENCRYPT('value',UNHEX(key))加密INSERT INTO `encrypt` (id,email,phone) VALUES (2,'test@qq.com', '55555555555');UPDATE `encrypt` set `email_e`= AES_ENCRYPT(`email`, UNHEX(@key)),`phone_e`= AES_ENCRYPT(`phone`, UNHEX(@key)) WHERE id =2;-- 对应的查询SELECT *,AES_DECRYPT(email_e, UNHEX(@key)) as eamil_value,AES_DECRYPT(phone_e, UNHEX(@key)) as phone_value FROM `encrypt` where id=2;-- 查询结果+----+-------------+-----------------+-------------+----------------+-------------+-------------+| id | email | email_e | phone | phone_e | eamil_value | phone_value |+----+-------------+-----------------+-------------+----------------+-------------+-------------+| 2 | test@qq.com | 一些乱码 | 55555555555 | 一些乱码 | test@qq.com | 55555555555 |+----+-------------+-----------------+-------------+----------------+-------------+-------------+ 注: 上面的sql查询中的email_e和phone_e原来的乱码会影响到本博客hexo-next的搜索功能加载不了,故用正常字符描述…tips: php 的composer库 phpseclib/phpseclib 可以用来处理PKCS＃1（v2.1）RSA，DES，3DES，RC4，Rijndael，AES，Blowfish，Twofish，SSH-1，SSH-2， SFTP和X.509故mysql的AES_ENCRYPT可以和php的这个库结合使用 2.2 ENCODE() 和 DECODE()ENCODE(‘需要编码字符串’, ‘token key’)DECODE(‘被编码的字段’, ‘token key’)该函数有两个参数：被加密或解密的字符串和作为加密或解密基础的密钥。Encode结果是一个二进制字符串，以BLOB类型存储。加密程度相对比较弱 123456-- 表结构同上SET @key = 'D7DF5B64DF1181EF1D62D646A13AA860';INSERT INTO `encrypt` (id,email,email_e,phone,phone_e) VALUES (5,'new@qq.com', ENCODE('new@qq.com', @key), '000000', ENCODE('000000', @key));SELECT *,DECODE(email_e, @key) as eamil_value,DECODE(phone_e, @key) as phone_value FROM `encrypt` where id=5; 3.case when的使用3.1 case when 用于查询:这里介绍三种使用方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `gender` tinyint(4) NOT NULL DEFAULT '1' COMMENT '1代表男,2代表女', `age` tinyint(4) NOT NULL, `country` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES ('1', '小明', '1', '20', '中国');INSERT INTO `user` VALUES ('2', 'Tom', '1', '18', 'USA');INSERT INTO `user` VALUES ('3', 'Sam', '2', '50', 'USA');INSERT INTO `user` VALUES ('4', '小华', '2', '22', '中国');INSERT INTO `user` VALUES ('5', '老张', '1', '70', '中国');INSERT INTO `user` VALUES ('6', 'Joe', '1', '75', 'USA');-- (1). CASE 字段1 WHEN 具体的值(不可为某个范围匹配) THEN 'value' ELSE 'valus' AS 字段别名,-- CASE 字段2 WHEN 具体的值 THEN 'value' ELSE 'value' AS 字段别名,SELECT *,CASE `country` WHEN '中国' THEN '龙的传入' ELSE '外国人' END AS '背景',CASE `gender` WHEN '1' THEN '男' ELSE '女' END AS '性别'FROM `user`;-- query result:+----+------+--------+-----+---------+----------+------+| id | name | gender | age | country | 背景 | 性别 |+----+------+--------+-----+---------+----------+------+| 1 | 小明 | 1 | 20 | 中国 | 龙的传入 | 男 || 2 | Tom | 1 | 18 | USA | 外国人 | 男 || 3 | Sam | 2 | 50 | USA | 外国人 | 女 || 4 | 小华 | 2 | 22 | 中国 | 龙的传入 | 女 || 5 | 老张 | 1 | 70 | 中国 | 龙的传入 | 男 || 6 | Joe | 1 | 75 | USA | 外国人 | 男 |+----+------+--------+-----+---------+----------+------+-- (2).CASE WHEN 单个字段 这个可以对字段进行取范围,也可具体值SELECT *, CASE WHEN `age` &lt; 30 THEN '青年'WHEN `age` BETWEEN 30 and 50 THEN '中年' WHEN `age` = 70 THEN '古稀' ELSE '老年' END AS '年龄'FROM `user`;-- query result:+----+------+--------+-----+---------+------+| id | name | gender | age | country | 年龄 |+----+------+--------+-----+---------+------+| 1 | 小明 | 1 | 20 | 中国 | 青年 || 2 | Tom | 1 | 18 | USA | 青年 || 3 | Sam | 2 | 50 | USA | 中年 || 4 | 小华 | 2 | 22 | 中国 | 青年 || 5 | 老张 | 1 | 70 | 中国 | 古稀 || 6 | Joe | 1 | 75 | USA | 老年 |+----+------+--------+-----+---------+------+-- (3)CASE WHEN 字段1,字段2，可以对多个字段进行替换SELECT *, CASE WHEN `age` &lt; 30 THEN '青年'WHEN `country` = '中国' THEN '龙的传入' ELSE '未知' END AS '备注'FROM `user`;-- query result:+----+------+--------+-----+---------+----------+| id | name | gender | age | country | 备注 |+----+------+--------+-----+---------+----------+| 1 | 小明 | 1 | 20 | 中国 | 青年 || 2 | Tom | 1 | 18 | USA | 青年 || 3 | Sam | 2 | 50 | USA | 未知 || 4 | 小华 | 2 | 22 | 中国 | 青年 || 5 | 老张 | 1 | 70 | 中国 | 龙的传入 || 6 | Joe | 1 | 75 | USA | 未知 |+----+------+--------+-----+---------+----------+ 3.2 case when 用于更新:12345678910111213141516171819202122232425-- (1).单个字段的更新示例:UPDATE `categories` SET `display_order` = CASE `id` WHEN 1 THEN 3 WHEN 2 THEN 4 WHEN 3 THEN 5 ELSE 0 ENDWHERE `id` IN (1,2,3)-- (2).多个字段的更新示例:UPDATE `categories` SET `author` = '小明', `update_time` = '2017-10-10', `display_order` = CASE `id` WHEN 1 THEN 3 WHEN 2 THEN 4 WHEN 3 THEN 5 ELSE 0 END, `title` = CASE `id` WHEN 1 THEN 'New Title 1' WHEN 2 THEN 'New Title 2' WHEN 3 THEN 'New Title 3' ELSE 'null' ENDWHERE `id` IN (1,2,3) 提醒: 在使用批量更新, 批量插入等方式的时候, 需要注意最终执行的sql语句的长度, 一般sql语句的长度默认最大 1M , 可通过mysql配置文件my.ini修改 max_allowed_packet(不推荐);建议: 在批量插入/更新时, 若担心语句过程, 可以将要添加或者更新的数据 分成 多个批次执行; 例如插入10000条数据, 可以每次插入2000条, 分五次执行; 4.给查询结果增加递增的序号列语法:select (@rowNO := @rowNo+1) AS rowno,其他字段 from (select @rowNO:=0) as temp, 查询的表….关于 := 说明 1Unlike =, the := operator is never interpreted as a comparison operator. This means you can use := in any valid SQL statement (not just in SET statements) to assign a value to a variable. 参考: https://dev.mysql.com/doc/refman/8.0/en/assignment-operators.html#operator_assign-value 4.1 示例:123456789101112131415161718192021222324252627-- ------------------------------ Table structure for Scores-- ----------------------------DROP TABLE IF EXISTS `Scores`;CREATE TABLE `Scores` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Score` float(5,2) NOT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- ------------------------------ Records of Scores-- ----------------------------INSERT INTO `Scores` VALUES ('1', '3.50');INSERT INTO `Scores` VALUES ('2', '3.65');INSERT INTO `Scores` VALUES ('3', '4.00');INSERT INTO `Scores` VALUES ('4', '3.85');INSERT INTO `Scores` VALUES ('5', '4.00');INSERT INTO `Scores` VALUES ('6', '3.65');-- 查询select (@rowNO := @rowNo+1) AS rowno,Score from (select @rowNO:=0) as temp, `Scores` ORDER BY Score desc;-- group by的自增序号-- 错误:select (@rowNO := @rowNo+1) AS rowno,Score from (select @rowNO:=0) as temp, `Scores` GROUP BY Score ORDER BY Score desc;-- 正确:select (@rowNO := @rowNo+1) AS rowno,s.Score from (select @rowNO:=0) as temp, (SELECT * from `Scores` GROUP BY Score ORDER BY Score desc) as s; 4.2 leetcode的一个题:编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。 +—-+——-+| Id | Score |+—-+——-+| 1 | 3.50 || 2 | 3.65 || 3 | 4.00 || 4 | 3.85 || 5 | 4.00 || 6 | 3.65 |+—-+——-+例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）： +——-+——+| Score | Rank |+——-+——+| 4.00 | 1 || 4.00 | 1 || 3.85 | 2 || 3.65 | 3 || 3.65 | 3 || 3.50 | 4 |+——-+——+ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rank-scores著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题目分析:先group by order by 拿到分数从高到底的排名,增加排名序号; 然后用分数表left join 按照分数高低排名即可 1234567891011121314151617181920212223-- ------------------------------ Table structure for Scores-- ----------------------------DROP TABLE IF EXISTS `Scores`;CREATE TABLE `Scores` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Score` float(5,2) NOT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- ------------------------------ Records of Scores-- ----------------------------INSERT INTO `Scores` VALUES ('1', '3.50');INSERT INTO `Scores` VALUES ('2', '3.65');INSERT INTO `Scores` VALUES ('3', '4.00');INSERT INTO `Scores` VALUES ('4', '3.85');INSERT INTO `Scores` VALUES ('5', '4.00');INSERT INTO `Scores` VALUES ('6', '3.65');-- 最终查询语句:select m.`Score`,convert(r.rowno, UNSIGNED) as Rank from Scores as m LEFT JOIN (select (@rowNO:= @rowNo+1) AS rowno,s.Score from (SELECT * FROM `Scores` group by `Score` order by `Score` desc ) as s, (select @rowNO:=0) as temp) as r on m.`Score`=r.`Score` ORDER BY m.`Score` desc; 5.类型转换convert, 首字符排序5.1.语法说明:MySQL 的CAST()和CONVERT()函数可用来获取一个类型的值，并产生另一个类型的值。两者具体的语法如下：CAST(value as type);CONVERT(value, type);即: CAST(xxx AS 类型), CONVERT(xxx,类型)。例如: SELECT CONVERT(‘23.00’, SIGNED); 可以转换的类型是有限制的。这个类型可以是以下值其中的一个：二进制，同带binary前缀的效果 : BINARY字符型，可带参数 : CHAR()日期 : DATE时间: TIME日期时间型 : DATETIME浮点数 : DECIMAL整数 : SIGNED无符号整数 : UNSIGNED 5.2.以汉字首字符排序name字段按照汉字正序 , 以name开头第一个字符来排序,依次是空格 0-9 a-z 字符 ,汉字首字拼音的首字母按照a-z来排序;select DISTINCT name from your_table order by convert(name using gbk) asc limit 300;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
