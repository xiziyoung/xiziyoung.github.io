<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bitmap-大数据存储]]></title>
    <url>%2F2019%2F07%2F26%2Fbitmap-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[二进制数据是用0和1两个数码来表示的数。 它的基数为2，进位规则是”逢二进一”，借位规则是”借一当二”。计算机是用数字电路搭成的，数字电路中只有1和0两种状态。我们可以利用二进制0和1代表两种不同的状态,来记录很多东西。例如是否登录,或者其他状态记录，但是该状态应该只有两种表现形式，因为二进制只有0和1只能记录两种不同的状态。 举例一: 例如一个用户信息表,里面要记录爱好:其中爱好有多个(篮球,羽毛球,足球,游戏,音乐……),供用户填写资料时勾选(可多选);传统的做法可以分表: 分为一个主要的用户表user(id, name), 一个爱好表hobby(id,hobby),然后一个中间表(id,user_id,hobby_id)关联用户id和爱好id;bitmap做法:只需要一个用户表,然后爱好字段也存入用户表user(id,name,hobby);采用位运算来存储和查询;二进制结构: 代表的爱好 二进制值 十进制数值 (类型一) 篮球 000001 1 (类型二) 羽毛球 000010 2 (类型三) 足球 000100 4 (类型四) 游戏 001000 8 (类型五) 音乐 010000 16 纵观二进制值的数据列,我们可以发现代表每种爱好类型的二进制对应的位数据为1,其他位为0;这正是bitmap的关键所在; 位运算(存储是用或运算, 查询时用与运算): 例子 名称 结果 $a &amp; $b And（按位与） 将把 $a 和 $b 中都为 1 的位设为 1。 $a | $b Or（按位或） 将把 $a 和 $b 中任何一个为 1 的位设为 1。 存储时:那么当一个用户(小明)同时勾选选篮球和羽毛球这两个爱好时, 我们将爱好的二进制进行 [或] 运算000001 | 000010 = 000011 (即10进制的3)然后当一个用户(小李)同时勾选选篮球,羽毛球,游戏这三个爱好时:000001 | 000010 | 001000 = 001011 (即10进制的11)此时的数据表: id name hobby 1 小明 3 2 小李 11 查询是:例如查找都爱好羽毛球的用户:羽毛球的二进制为:000010, 我们拿小明的hobby = 3(即二进制 000011) 和羽毛球的二进制值进行 [与] 运算:000011 &amp; 000010 = 000010 即数值3&gt;0, 得到小明爱好有羽毛球同理:小李查找位运算 [hobby | 羽毛球] 为:001011 &amp; 000010 = 000010 &gt; 0, 小李也爱好羽毛球; mysql本身支持位运算查询:SELECT * FROM user where hobby&amp;2 &gt; 0; (即可查到小明和小李); 举例二 以下示例中二进制位0,1分别代码未签到,已签到两种状态;例如有个需求，（1）记录每个用户每天是否签到（2）统计某一个月没有断签的用户（3）查看某个用户连续签到的情况 常规方式：使用一张签到log表,字段user_id, date;每次用户签到就在该log表中记录下用户id和签到日期;针对需求(2)统计没有断签也简单啊,where 月份区间 count一下看天数是否满足;针对需求(3)可以加个字段记录是否连续签到;但是这样的话每天1000万的用户签到就是1000万条记录数据,一年就是365*1000万的数据量; 使用bitmap利用二进制的0和1分别代表&lt;未签到,签到&gt;两种不同的状态;签到log表:字段user_id, year, mouth, record(该用户当月签到记录)(int); 假设小明 user_id 为100, 18年的3月份他分别在1,2,3,10,20,30,31号进行了签到;利用二进制位(此处采用32位)来表示小明该月份的签到情况如下:(下面32位数字,从左往右分别带表3月1号到32号,不要纠结没有32号) 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 1该数值转为十进制为1611137543所以log表中表示小明该月签到的情况为: user_id year mouth record 100 2018 3 1611137543 这样, 一条sql记录就能存储一个用户一个月的签到情况了; 说明:在很多情况下,我们可能需要的是记录某一天有多少个会员的签到情况,而不是某个会员的签到情况,这个怎么使用bitmap了我们需要采用会员id横向存储,以天为单位,把签到的会员id存入数据中,数据库只需要查询某一天的bitmap数据,就能得到某一天的所有会员签到情况;签到log表设计: date(日期), section(用户id/32向上取整落在的区间段值),user_ids_record(对应id用户在该日期签到的情况)(int);假设 user_id为1,10,20,32,100,1000,10000的用户在2018-3-10签到了:(1).利用这些用户id除以32取整;为什么除以32,是因为mysql的int类型是32位(即4字节的8位);(2).不同用户idsection的取值:1,10,20,32 除以32 向上取整为1,所以这些用户id对应的section=1;100,1000,10000 除以32 向上取整分别为4,32,313;(3).不同用户id在user_ids_record所处的位置:user_id%32的值, 即用户id取模32的值即该用户在user_ids_record表示的32个二进制位中的位置(从左往右);例如100/32向上取整为4,100%32也为4,那么如果区间4只有100这个用户签到就会有这样一条记录:2018-3-10,4,8(二进制数为1000);(4).最终2018-3-10的签到记录表如下(这一天只有user_id为1,10,20,32,100,1000,10000这些用户签到了): date section user_ids_record 备注的二进制值 2018-3-10 1 2148008449 10000000000010000000001000000001 2018-3-10 4 8 00000000000000000000000000001000 2018-3-10 32 128 00000000000000000000000010000000 2018-3-10 313 32768 00000000000000001000000000000000 如果上面的例子采用mysql的数据类型为BIGINT(占用8个字节,即64位),则一条记录可以存储64个用户的签到情况; tips: 计算机存储信息的最小单位，称之为位（bit，又称比特）; 存储器中所包含存储单元的数量称为存储容量，其计量基本单位是字节（Byte。简称B），8个二进制位称为1个字节，此外还有KB、MB、GB、TB等，它们之间的换算关系是: 1Byte＝8bit，1KB=1024B，1MB=1024KB，1GB=1024MB，1TB=1024GB。 所谓的位指的是CPU一次数据读取的最大量！64位CPU代表CPU一次可以读写64bits这么多的数据，32位CPU则是CPU一次只能读取32位的意思。 因为CPU读取数据量有限制，因此能够从内存中读写的数据也就有所限制。所以，一般32位的CPU所能读写的最大数据量，大概就是4GB左右. bitmap的缺点: bitmap不能存储多状态情况,bitmap只有0和1 两个状态,无法做多状态的存储;bitmap不能存储重复数据,bitmap是通过不同的位数,代表不同的数据和不同的状态,不能通过bitmap存储重复的数据;bitmap受int位数限制,在32位机器上,int只有32位4个字节,所以你一个int数据只能最多存储32条数据.(有些语言的int类型在32/64位机器上的位数大小和其语言的解释器有关)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql幻读]]></title>
    <url>%2F2019%2F07%2F05%2Fmysql%E5%B9%BB%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[事务隔离级别mysql 有四级事务隔离级别: (图来自: &lt;高性能mysql一书&gt;) 解释: 脏读: 在事务T1中可以读取到事务T2中还没提交的更新; 不可重复读: 事务T1能够读取到事务T2提交后的更新, 这将导致事务T1在T2提交前后读取到的数据不一样, 即不可重复读; 幻读: 幻读，并不是指在同一事务中执行两次同样的sql语句获取到的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。 幻读举例: 1.幻读的产生:下面用REPEATABLE-READ隔离级别举例说明 查看看事务隔离级别和测试表(innodb存储引擎的表)结构: 12345678910111213141516171819202122232425262728293031mysql&gt; select @@global.tx_isolation, @@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in setmysql&gt; mysql&gt; desc test;+-------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(255) | NO | | NULL | |+-------+--------------+------+-----+---------+----------------+2 rows in set (1). 事务T1中123456789mysql&gt; begin;Query OK, 0 rows affectedmysql&gt; select * from test where id =1;Empty setmysql&gt; (2). 事务T2:1234567891011121314151617181920212223242526272829mysql&gt; begin;Query OK, 0 rows affectedmysql&gt; select * from test where id =1;Empty setmysql&gt; insert into test values (1, &apos;first&apos;);Query OK, 1 row affectedmysql&gt; commit;Query OK, 0 rows affectedmysql&gt; select * from test where id =1;+----+-------+| id | name |+----+-------+| 1 | first |+----+-------+1 row in set (3). 回到事务T1中:12345678910111213mysql&gt; select * from test where id =1;Empty setmysql&gt; insert into test values(1, &apos;second&apos;);1062 - Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;mysql&gt; mysql&gt; select * from test where id =1;Empty set 我们可以看到在T2事务的中途干扰下, 导致T1事务出现了幻读 : 在事务T1中查询 id=1的数据不存在, 但指定id为1插入数据时又会抛出错误 Duplicate entry ‘1’ for key ‘PRIMARY’ , 然后我们在出现插入错误提示后, 在T1中查询id=1的数据还是不存在。 2.SERIALIZABLE防止幻读的方式因为在该隔离级别下, 会给读取到的每一条数据强制加锁 (数据行存在加 X锁, 不存在的加Gap Lock锁 ), 即记录存在与否，mysql 都会对记录应该对应的索引加锁，其他事务是无法再获得做操作的。 MySQL InnoDB支持三种行锁定方式： 行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key。 间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而已的。 Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php递归和引用实现的无限极分类]]></title>
    <url>%2F2018%2F07%2F12%2Fphp%E9%80%92%E5%BD%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[无限极分类类似省、市、区,构建成一个父级下面有多个子元素的数据结构;子元素与父元素之间通常使用id和parentId来关联; php递归实现无限极分类:该方法实现的无限极分类在数据量和子层级较多时,很慢,因为递归调用每次都要遍历大量的数据;代码示例: 1234567891011121314151617181920212223&lt;?phpfunction buildTreeByRecursion(array $elements, $rootValue = 0, $parentField = "parent", $index = '', $level = 0)&#123; $branch = array(); $level++; foreach ($elements as $k =&gt; $element) &#123; $element['_level'] = $level; if ($element[$parentField] == $rootValue) &#123; unset($elements[$k]);//减轻下次递归时遍历的数量 $children = buildTreeByRecursion($elements, $element['id'], $parentField, $index, $level); if ($children) &#123; $element['children'] = $children; &#125; if (empty($index)) &#123; $branch[] = $element; &#125; else &#123; $branch[$element[$index]] = $element; &#125; &#125; &#125; return $branch;&#125; php引用传值方式实现无限极分类首先我们看下简单php的引用传值: 12345678910111213141516171819&lt;?php$list = [ 0 =&gt; ['id' =&gt; 1,], 1 =&gt; ['id' =&gt; 2,], 2 =&gt; ['id' =&gt; 3,]];$tree = [ 0 =&gt; &amp;$list[0], 1 =&gt; &amp;$list[1], 2 =&gt; $list[2],];var_dump($tree);$list[0]['children'] = ['first new child'];$list[1]['children'] = ['second new child'];$list[2]['children'] = ['third new child'];var_dump($tree);exit(); php的应用传值是将变量对应的内存地址指向同一个地址,即$a = &amp;$b;那么修改$a或者$b的值,实际相当于修改的是他们在内存中的地址处的值, 那么两个变量的值都将变化,因为他们的地址指向的值变了; 地址引用无限极分类:该方法很快, 因为不用像递归那样多次遍历数据; 12345678910111213141516171819202122&lt;?phpfunction getTreeByQuote($list, $pid = 0, $parentField = 'parent')&#123; $tree = []; if (!empty($list)) &#123; //第一步 构造数据:修改为以id为下标的列表 $newList = []; foreach ($list as $k =&gt; $v) &#123; $newList[$v['id']] = $v; &#125; //第二步: 遍历数据,生成树状结构 foreach ($newList as $value) &#123; if ($pid == $value[$parentField]) &#123; $tree[] = &amp;$newList[$value['id']]; &#125; elseif (isset($newList[$value[$parentField]])) &#123; $newList[$value[$parentField]]['children'][] = &amp;$newList[$value['id']]; &#125; &#125; &#125; return $tree;&#125; 测试: 1234567891011121314151617181920&lt;?php/*** 前面的递归和引用实现无限极分类函数 */$data = file_get_contents('./category.json');$data = json_decode($data, true);$_base_time = time();$_base = memory_get_usage();//$res = buildTreeByRecursion($data, 0, 'parentId');$res = getTreeByQuote($data, 0, 'parentId');$_end_time = time();$_end = memory_get_usage();var_dump('内存使用'.(int)(($_end-$_base)/1024).'kb'); var_dump('时间使用'.($_end_time-$_base_time).'s');var_dump($res);exit();echo json_encode($res, JSON_UNESCAPED_UNICODE);exit(); 测试数据: 4818条数据,其中一级44个,二级元素452个,三级元素4326个;递归方式,内存使用2082kb,时间使用11s;引用方式,内存使用608kb,时间使用0s;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql死锁]]></title>
    <url>%2F2018%2F07%2F06%2Fmysql%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[mysql中的锁:在MySQL中的锁分两大类，一种是读锁，一种是写锁，读锁（read lock）也可以称为共享锁（shared lock），写锁（write lock）也通常称为排它锁（exclusive lock）。 读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取一个资源，且互不干扰。写锁则是排他的，就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。 (待补充: 锁力度,行锁,间隙锁等) 死锁: 死锁模拟表结构: 12345CREATE TABLE `test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; 事务一T1中: 12345678mysql&gt; START TRANSACTION;Query OK, 0 rows affectedmysql&gt; update `test` set `name`="T1" where `id`=1;Query OK, 1 row affectedRows matched: 1 Changed: 1 Warnings: 0mysql&gt; ​ 事务二T2中: 新的事务T2 12345678mysql&gt; START TRANSACTION;Query OK, 0 rows affectedmysql&gt; update `test` set `name`="T1" where `id`=3;Query OK, 1 row affectedRows matched: 1 Changed: 1 Warnings: 0mysql&gt; 事务T1: 事务T1也执行删除操作 12mysql&gt; update `test` set `name`=&quot;T1&quot; where `id`=3;---阻塞等待中,等待T2释放id=3记录的X锁 事务T2 123mysql&gt; update `test` set `name`=&quot;T2&quot; where `id`=1;1213 - Deadlock found when trying to get lock; try restarting transactionmysql&gt; 事务T2抛错, 事务T1继续执行: 123456mysql&gt; update `test` set `name`="T1" where `id`=3;Query OK, 1 row affectedRows matched: 1 Changed: 1 Warnings: 0mysql&gt; mysql&gt; commit;Query OK, 0 rows affected 发生死锁后，InnoDB会为对一个客户(此处为 事务T2)产生错误信息并释放锁。返回给客户的信息： 12Deadlock found when trying to get lock;try restarting transaction 所以，另一个客户(事务T1)可以正常执行任务。死锁结束。 日常注意:事务尽量简单化: 123456789101112131415 //各种其他可以不在事务中执行的操作,应该在事务外执行,例如其他的数据获取,数据处理,数据格式调整,其他耗时处理等等$this-&gt;beginTrans(); //在事务内, 尽量只集中处理事务该处理的sql部分 try &#123; $this-&gt;update(); //因为在事务中,处理这些,事务就会等待这些处理完了,再提交或者回滚,那样事务内的锁就会挂起太久, 容易导致死锁问题 $this-&gt;delete(); $this-&gt;commit(); &#125; catch (Exception $e) &#123; $this-&gt;rollBack(); throw new MessageException('操作失败', 0); &#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql优化]]></title>
    <url>%2F2018%2F04%2F08%2Fmysql%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[查询优化 多用DESC 或者 EXPLAIN分析查询情况; 常规: 使用缓存, 缓存技术在很多时候能很好的解决数据库查询慢的问题 不要使用select *，只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量;(以下示例为了简洁, 大量使用了select *, 实际项目中尽量避免) 避免limit 的 offset值过大select * from test_table where sex = ‘M’ limit 1000000,10;无论如何优化索引,这个查询都将很慢,因为随着便宜量的增加,mysql需要扫描大量需要丢弃的数据;可以通过限制用户能够翻页的数据量来避免该问题,一般也没用户在意搜索结果的上千页; 延迟关联 允许为null的列，查询有潜在大坑:SELECT * FROM test_table where name != ‘tom’;该查询结果集中将不包括name is null 的情况;建议:设计表是字段尽量用not null约束以及给默认值。 如果明确知道只有一条结果返回，limit 1能够提高效率例如你里系统用户不允许一个邮箱注册多个账号,即一个邮箱在用户表里只会有一条有效记录.select * from user where email=’123456@qq.com’;可以优化为：select * from user where email=’123456@qq.com’ limit 1;原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动 分解大连接查询连表查询虽然能让我们更方便的拿到想要的数据, 但应该避免多个大表的连接查询, 连表过多会导致查询慢(特表是很多大表连接,且无法很好的用索引优化到查询时);可以先查出主要的数据结果集, 然后利用结果集中的关联字段去对应表中查询到关联结果集,再用程序将关联结果集聚合到总的数据结果集中;或者先查出小表的数据集,然后用这个数据集join大表; 索引:索引对于良好的性能非常关键,尤其是在表数据量大时; 索引可以先简单理解为书的目录,可以帮你快速定位你想看的内容所在的页码;索引类型:PRIMARY key 主键, normal 一般、unique 唯一、full text 全文 特别说明:当查询需要访问大多数行时，顺序读取比通过索引更快。顺序读取可以最大限度地减少磁盘搜索，即使查询不需要所有行也是如此。mysql优化器会基于其他因素,如表大小、行数、I/O块大小来决定是使用索引还是表扫描.一般对于非常小的表 或者 对于大表的大部分数据量的查询(最佳索引跨越表的30%以上), 查询将进行全表扫描; 123-- 例如你在user表中查询sex='男'的记录;sex列建有索引, 但sex='男'的记录占总数据量的50%时;EXPLAIN SELECT * FROM `user` where `sex`='男';-- 你将看到查询分析的 possible_keys=sex,但是type=ALL,key=Null , 这说明实际并没走索引,而是进行的全表扫描; 所以在测试下面索引的用法时: 如果发现没有按照你的预期,出现了全表扫描, 请先看下是否是小表或者大表查询超过数据量的30%导致的; 索引优化常见注意事项: 查询经常用到的高频字段,用来连表的关联字段 最好建立上索引; 前导模糊查询不能命中索引;例如: select * from test_table where name like ‘%XX’; 无法使用索引而非前导模糊查询则可以：select * from test_table where name like ‘XX%’; 负向条件查询不能命中索引select * from test_table where age != 30;包括 not in等;not in/not exists都不是好习惯;(not exists比not in 好 , not exists可以走索引,避免不了负向查询就尽量用exists或者not exists); 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。explain select * from test_table where YEAR(date) &lt; ‘2019’;即使date列有索引, 改查询也将无法命中索引;类似的还有下面的这种神操作:EXPLAIN SELECT * FROM user where age+1 = 49; 无法命中age索引;233333计算尽量放到业务层完成,而非数据库层 B-Tree索引中,复合索引(多列索引)最左前缀原则:(说明:该项适用与B-Tree索引;哈希和其他类型的索引并不会像B-Tree一样按照顺序存储)即索引key(field1, field2, field3),要想很好利用该索引,需要你的查询语句能使用到靠左的字段,将索引中从左起到右的字段 部分/全部 使用到查询语句中;例如: 12345678910111213141516171819202122232425262728293031323334353637CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `gender` tinyint(4) NOT NULL DEFAULT '1' COMMENT '1代表男,2代表女', `age` tinyint(4) NOT NULL, `country` varchar(255) NOT NULL, `work` varchar(255) NOT NULL, PRIMARY KEY (`id`), KEY `user_composite_index` (`country`,`work`,`age`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;-- (1).可以很好用到索引user_composite_index的情况EXPLAIN SELECT * FROM `user` WHERE `country`='EN';EXPLAIN SELECT * FROM `user` WHERE `country`='EN' AND `work`='IT';EXPLAIN SELECT * FROM `user` WHERE `country`='EN' AND `work`='IT' ORDER BY `age` desc; -- sql语句中的写法顺序好像没有关系,如下也可 EXPLAIN SELECT * FROM `user` WHERE age=50 AND `country`='EN' AND `work`='IT';-- (2).完全无法使用索引user_composite_index的情况EXPLAIN SELECT * FROM `user` WHERE `work`='IT';EXPLAIN SELECT * FROM `user` WHERE `age` = 50;EXPLAIN SELECT * FROM `user` WHERE `work`='IT' ORDER BY `age` desc;EXPLAIN SELECT * FROM `user` WHERE `country`!='EN' AND `work`='IT' ORDER BY `age` desc;-- (3).部分使用到索引的情况explain SELECT * FROM `user` WHERE `country`='EN' AND `age`=50;explain SELECT * FROM `user` WHERE `country`='EN' AND `work`!='IT' AND `age`=50;+----+-------------+-------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | user | NULL | range | user_composite_index | user_composite_index | 1534 | NULL | 2 | 14.29 | Using index condition |+----+-------------+-------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+通过查看执行计划filtered,这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。 此处不为100%; 因为`work`使用了不等于,负向查询导致`work`没使用到索引; 后面的`age`因为在其左的`work`没命中索引,也将无法命中索引. 所以，在创建复合索引时，要根据业务需求，where子句中查询使用最频繁的一列放在索引最左边。 对于范围条件查询,Mysql无法再使用范围列后面的其他索引了,但对于”多个等值条件查询”则没有这个限制; 123456789101112131415161718192021222324CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `age` tinyint(4) NOT NULL, `work` varchar(255) NOT NULL, PRIMARY KEY (`id`), KEY `age_work` (`age`,`work`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;mysql&gt; EXPLAIN SELECT * FROM `user` where age in (70,75) and `work`='DOCTOR';+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | user | NULL | range | age_work | age_work | 768 | NULL | 2 | 100 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+1 row in setmysql&gt; mysql&gt; EXPLAIN SELECT * FROM `user` where age &gt;=70 and `work`='DOCTOR';+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | user | NULL | range | age_work | age_work | 768 | NULL | 12 | 10 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+1 row in set通过查看filtered是否为100%来判断多列索引的利用情况 索引列的顺序让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 123456789SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment;-- 结果: staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 强制类型转换会全表扫描例如: 1234567891011121314151617181920212223242526272829-- 商品表中serial_number 类型为varchar(15),该列添加的有索引CREATE TABLE `goods` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `serial_number` varchar(15) NOT NULL, PRIMARY KEY (`id`), KEY `serial_number` (`serial_number`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- 使用字符串时,查询使用到了索引mysql&gt; desc SELECT * FROM `goods` where serial_number='123456';+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+| 1 | SIMPLE | goods | NULL | ref | serial_number | serial_number | 47 | const | 1 | 100 | NULL |+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+1 row in set-- 使用int类型去强制转换时,查询未使用到索引, type为all,说明全表扫描了mysql&gt; mysql&gt; desc SELECT * FROM `goods` where serial_number=123456;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | goods | NULL | ALL | serial_number | NULL | NULL | NULL | 4 | 25 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in setmysql&gt; 覆盖查询:仅使用索引树中的信息从表中检索列信息，而不必执行额外的搜索以读取实际行。即索引包含所有需要查询的字段的值。具有以下优点： 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。 设计优化 缓存mysql服务自身提供的有缓存系统,可以开启缓存;但建议使用redis/memcached 分区基本概念，把一个表，从逻辑上分成多个区域，便于存储数据。采用分区的前提，数据量非常大。如果数据表的记录非常多，比如达到上亿条，数据表的活性就大大降低，数据表的运行速度就比较慢、效率低下，影响mysql数据库的整体性能，就可以采用分区解决，分区是mysql本身就支持的技术 分表水平拆分：是把一个表的全部记录信息分别存储到不同的分表之中。程序需要注意的是从哪个表读入,向哪个表更新; 垂直拆分：是把一个表的全部字段分别存储到不同的表里边。 清理数据碎片读写分离表结构设计]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql使用]]></title>
    <url>%2F2017%2F08%2F10%2Fmysql%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[开篇:mysql的书写顺序: 123456select *columns* from *tables* where *predicae1* group by *columns* having *predicae1* order by *columns* limit *start*, *offset*; 但是mysql的查询执行顺序并不是按照书写顺序来的,而是按照如下的执行顺序: 1234567from *tables*where *predicae1*group by *columns*having *predicae1*select *columns*order by *columns*limit *start*, *offset*; 1.多个值的 IN 匹配语法: (字段1, 字段2) IN ( (字段1的结果1, 字段2的结果1), (字段1的结果2, 字段2的结果2) )语法示例: select * from table where (field1, field2) in ( (field1_value,field2_value) , (field1_value, field2_value), (field1_value, field2_value) );完整举例: 123456789101112131415161718192021222324252627-- ------------------------------ Table structure for Employee-- ----------------------------DROP TABLE IF EXISTS `Employee`;CREATE TABLE `Employee` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Name` varchar(255) NOT NULL, `Salary` int(11) NOT NULL, `DepartmentId` int(11) NOT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- ------------------------------ Records of Employee-- ----------------------------INSERT INTO `Employee` VALUES ('1', 'Joe', '70000', '1');INSERT INTO `Employee` VALUES ('2', 'Henry', '80000', '2');INSERT INTO `Employee` VALUES ('3', 'Sam', '60000', '2');INSERT INTO `Employee` VALUES ('4', 'Max', '90000', '1');INSERT INTO `Employee` VALUES ('5', 'Tom', '90000', '1');-- 查询语句:SELECT `Name` , `Salary`, `DepartmentId` FROM `Employee` where (Salary,DepartmentId) in((90000,1), (80000,2));-- 等价于: SELECT `Name` , `Salary`, `DepartmentId` FROM `Employee` where (`DepartmentId`, `Salary`) in (SELECT `DepartmentId`,MAX(`Salary`) as Salary FROM `Employee` GROUP BY `DepartmentId`); 2.字段加密常见的:SELECT MD5(‘123’);SELECT SHA(‘123’);SELECT PASSWORD(‘123’);MD5()：计算字符串的MD5校验和SHA：计算字符串的SHA校验和PASSWORD()：创建一个经过加密的密码字符串，适合于插入到MySQL的安全系统。该加密过程不可逆，和unix密码加密过程使用不同的算法。主要用于MySQL的认证系统。加密函数非常之多,官网:https://dev.mysql.com/doc/refman/8.0/en/encryption-functions.html 2.1 AES_ENCRYPT 和 AES_DECRYPT (推荐)使用AES算法解密/加密其加密的结果最好使用blob类型存储;语法: AES_ENCRYPT(‘要加密的值’, ‘token key’) AES_DECRYPT(‘被加密的字段’, ‘token key’) 123456789101112131415161718192021222324252627282930313233343536CREATE TABLE `encrypt` ( `id` int(11) NOT NULL AUTO_INCREMENT, `email` varchar(255) NOT NULL, `email_e` varbinary(255) DEFAULT NULL, `phone` varchar(255) NOT NULL, `phone_e` varbinary(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- 首先设置用来加密的key值, 该变量在以下语句中使用SET @key = 'D7DF5B64DF1181EF1D62D646A13AA860';-- (1)-- 添加完整的数据, email_e和phone_e使用AES_ENCRYPT('value',key)加密INSERT INTO `encrypt` (id,email,email_e,phone,phone_e) VALUES (1,'123456@qq.com', AES_ENCRYPT('123456@qq.com', @key), '12345678901', AES_ENCRYPT('12345678901', @key));-- 使用 AES_DECRYPT(field, key)来解密,查询 SELECT *,AES_DECRYPT(email_e, @key) as eamil_value,AES_DECRYPT(phone_e, @key) as phone_value FROM `encrypt` where id=1;-- 查询结果 +----+---------------+----------------+-------------+----------------+---------------+-------------+| id | email | email_e | phone | phone_e | eamil_value | phone_value |+----+---------------+----------------+-------------+----------------+---------------+-------------+| 1 | 123456@qq.com | 一些乱码 | 12345678901 | 一些乱码 | 123456@qq.com | 12345678901 |+----+---------------+----------------+-------------+----------------+---------------+-------------+-- (2)-- 你还可以对key再次的转变一次, 例如使用UNHEX, 即AES_ENCRYPT('value',UNHEX(key))加密INSERT INTO `encrypt` (id,email,phone) VALUES (2,'test@qq.com', '55555555555');UPDATE `encrypt` set `email_e`= AES_ENCRYPT(`email`, UNHEX(@key)),`phone_e`= AES_ENCRYPT(`phone`, UNHEX(@key)) WHERE id =2;-- 对应的查询SELECT *,AES_DECRYPT(email_e, UNHEX(@key)) as eamil_value,AES_DECRYPT(phone_e, UNHEX(@key)) as phone_value FROM `encrypt` where id=2;-- 查询结果+----+-------------+-----------------+-------------+----------------+-------------+-------------+| id | email | email_e | phone | phone_e | eamil_value | phone_value |+----+-------------+-----------------+-------------+----------------+-------------+-------------+| 2 | test@qq.com | 一些乱码 | 55555555555 | 一些乱码 | test@qq.com | 55555555555 |+----+-------------+-----------------+-------------+----------------+-------------+-------------+ 注: 上面的sql查询中的email_e和phone_e原来的乱码会影响到本博客hexo-next的搜索功能加载不了,故用正常字符描述…tips: php 的composer库 phpseclib/phpseclib 可以用来处理PKCS＃1（v2.1）RSA，DES，3DES，RC4，Rijndael，AES，Blowfish，Twofish，SSH-1，SSH-2， SFTP和X.509故mysql的AES_ENCRYPT可以和php的这个库结合使用 2.2 ENCODE() 和 DECODE()ENCODE(‘需要编码字符串’, ‘token key’)DECODE(‘被编码的字段’, ‘token key’)该函数有两个参数：被加密或解密的字符串和作为加密或解密基础的密钥。Encode结果是一个二进制字符串，以BLOB类型存储。加密程度相对比较弱 123456-- 表结构同上SET @key = 'D7DF5B64DF1181EF1D62D646A13AA860';INSERT INTO `encrypt` (id,email,email_e,phone,phone_e) VALUES (5,'new@qq.com', ENCODE('new@qq.com', @key), '000000', ENCODE('000000', @key));SELECT *,DECODE(email_e, @key) as eamil_value,DECODE(phone_e, @key) as phone_value FROM `encrypt` where id=5; 3.case when的使用3.1 case when 用于查询:这里介绍三种使用方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `gender` tinyint(4) NOT NULL DEFAULT '1' COMMENT '1代表男,2代表女', `age` tinyint(4) NOT NULL, `country` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES ('1', '小明', '1', '20', '中国');INSERT INTO `user` VALUES ('2', 'Tom', '1', '18', 'USA');INSERT INTO `user` VALUES ('3', 'Sam', '2', '50', 'USA');INSERT INTO `user` VALUES ('4', '小华', '2', '22', '中国');INSERT INTO `user` VALUES ('5', '老张', '1', '70', '中国');INSERT INTO `user` VALUES ('6', 'Joe', '1', '75', 'USA');-- (1). CASE 字段1 WHEN 具体的值(不可为某个范围匹配) THEN 'value' ELSE 'valus' AS 字段别名,-- CASE 字段2 WHEN 具体的值 THEN 'value' ELSE 'value' AS 字段别名,SELECT *,CASE `country` WHEN '中国' THEN '龙的传入' ELSE '外国人' END AS '背景',CASE `gender` WHEN '1' THEN '男' ELSE '女' END AS '性别'FROM `user`;-- query result:+----+------+--------+-----+---------+----------+------+| id | name | gender | age | country | 背景 | 性别 |+----+------+--------+-----+---------+----------+------+| 1 | 小明 | 1 | 20 | 中国 | 龙的传入 | 男 || 2 | Tom | 1 | 18 | USA | 外国人 | 男 || 3 | Sam | 2 | 50 | USA | 外国人 | 女 || 4 | 小华 | 2 | 22 | 中国 | 龙的传入 | 女 || 5 | 老张 | 1 | 70 | 中国 | 龙的传入 | 男 || 6 | Joe | 1 | 75 | USA | 外国人 | 男 |+----+------+--------+-----+---------+----------+------+-- (2).CASE WHEN 单个字段 这个可以对字段进行取范围,也可具体值SELECT *, CASE WHEN `age` &lt; 30 THEN '青年'WHEN `age` BETWEEN 30 and 50 THEN '中年' WHEN `age` = 70 THEN '古稀' ELSE '老年' END AS '年龄'FROM `user`;-- query result:+----+------+--------+-----+---------+------+| id | name | gender | age | country | 年龄 |+----+------+--------+-----+---------+------+| 1 | 小明 | 1 | 20 | 中国 | 青年 || 2 | Tom | 1 | 18 | USA | 青年 || 3 | Sam | 2 | 50 | USA | 中年 || 4 | 小华 | 2 | 22 | 中国 | 青年 || 5 | 老张 | 1 | 70 | 中国 | 古稀 || 6 | Joe | 1 | 75 | USA | 老年 |+----+------+--------+-----+---------+------+-- (3)CASE WHEN 字段1,字段2，可以对多个字段进行替换SELECT *, CASE WHEN `age` &lt; 30 THEN '青年'WHEN `country` = '中国' THEN '龙的传入' ELSE '未知' END AS '备注'FROM `user`;-- query result:+----+------+--------+-----+---------+----------+| id | name | gender | age | country | 备注 |+----+------+--------+-----+---------+----------+| 1 | 小明 | 1 | 20 | 中国 | 青年 || 2 | Tom | 1 | 18 | USA | 青年 || 3 | Sam | 2 | 50 | USA | 未知 || 4 | 小华 | 2 | 22 | 中国 | 青年 || 5 | 老张 | 1 | 70 | 中国 | 龙的传入 || 6 | Joe | 1 | 75 | USA | 未知 |+----+------+--------+-----+---------+----------+ 3.2 case when 用于更新:12345678910111213141516171819202122232425-- (1).单个字段的更新示例:UPDATE `categories` SET `display_order` = CASE `id` WHEN 1 THEN 3 WHEN 2 THEN 4 WHEN 3 THEN 5 ELSE 0 ENDWHERE `id` IN (1,2,3)-- (2).多个字段的更新示例:UPDATE `categories` SET `author` = '小明', `update_time` = '2017-10-10', `display_order` = CASE `id` WHEN 1 THEN 3 WHEN 2 THEN 4 WHEN 3 THEN 5 ELSE 0 END, `title` = CASE `id` WHEN 1 THEN 'New Title 1' WHEN 2 THEN 'New Title 2' WHEN 3 THEN 'New Title 3' ELSE 'null' ENDWHERE `id` IN (1,2,3) 提醒: 在使用批量更新, 批量插入等方式的时候, 需要注意最终执行的sql语句的长度, 一般sql语句的长度默认最大 1M , 可通过mysql配置文件my.ini修改 max_allowed_packet(不推荐);建议: 在批量插入/更新时, 若担心语句过程, 可以将要添加或者更新的数据 分成 多个批次执行; 例如插入10000条数据, 可以每次插入2000条, 分五次执行; 4.给查询结果增加递增的序号列语法:select (@rowNO := @rowNo+1) AS rowno,其他字段 from (select @rowNO:=0) as temp, 查询的表….关于 := 说明 123456789101112131415161718192021222324252627282930313233Unlike =, the := operator is never interpreted as a comparison operator. This means you can use := in any valid SQL statement (not just in SET statements) to assign a value to a variable.``` 参考: https://dev.mysql.com/doc/refman/8.0/en/assignment-operators.html#operator_assign-value ### 4.1 示例: ```sql-- ------------------------------ Table structure for Scores-- ----------------------------DROP TABLE IF EXISTS `Scores`;CREATE TABLE `Scores` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Score` float(5,2) NOT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- ------------------------------ Records of Scores-- ----------------------------INSERT INTO `Scores` VALUES (&apos;1&apos;, &apos;3.50&apos;);INSERT INTO `Scores` VALUES (&apos;2&apos;, &apos;3.65&apos;);INSERT INTO `Scores` VALUES (&apos;3&apos;, &apos;4.00&apos;);INSERT INTO `Scores` VALUES (&apos;4&apos;, &apos;3.85&apos;);INSERT INTO `Scores` VALUES (&apos;5&apos;, &apos;4.00&apos;);INSERT INTO `Scores` VALUES (&apos;6&apos;, &apos;3.65&apos;);-- 查询select (@rowNO := @rowNo+1) AS rowno,Score from (select @rowNO:=0) as temp, `Scores` ORDER BY Score desc;-- group by的自增序号-- 错误:select (@rowNO := @rowNo+1) AS rowno,Score from (select @rowNO:=0) as temp, `Scores` GROUP BY Score ORDER BY Score desc;-- 正确:select (@rowNO := @rowNo+1) AS rowno,s.Score from (select @rowNO:=0) as temp, (SELECT * from `Scores` GROUP BY Score ORDER BY Score desc) as s; 4.2 leetcode的一个题:编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。 +—-+——-+| Id | Score |+—-+——-+| 1 | 3.50 || 2 | 3.65 || 3 | 4.00 || 4 | 3.85 || 5 | 4.00 || 6 | 3.65 |+—-+——-+例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）： +——-+——+| Score | Rank |+——-+——+| 4.00 | 1 || 4.00 | 1 || 3.85 | 2 || 3.65 | 3 || 3.65 | 3 || 3.50 | 4 |+——-+——+ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rank-scores著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题目分析:先group by order by 拿到分数从高到底的排名,增加排名序号; 然后用分数表left join 按照分数高低排名即可 1234567891011121314151617181920212223-- ------------------------------ Table structure for Scores-- ----------------------------DROP TABLE IF EXISTS `Scores`;CREATE TABLE `Scores` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Score` float(5,2) NOT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;-- ------------------------------ Records of Scores-- ----------------------------INSERT INTO `Scores` VALUES ('1', '3.50');INSERT INTO `Scores` VALUES ('2', '3.65');INSERT INTO `Scores` VALUES ('3', '4.00');INSERT INTO `Scores` VALUES ('4', '3.85');INSERT INTO `Scores` VALUES ('5', '4.00');INSERT INTO `Scores` VALUES ('6', '3.65');-- 最终查询语句:select m.`Score`,convert(r.rowno, UNSIGNED) as Rank from Scores as m LEFT JOIN (select (@rowNO:= @rowNo+1) AS rowno,s.Score from (SELECT * FROM `Scores` group by `Score` order by `Score` desc ) as s, (select @rowNO:=0) as temp) as r on m.`Score`=r.`Score` ORDER BY m.`Score` desc; 5.类型转换convert, 首字符排序5.1.语法说明:MySQL 的CAST()和CONVERT()函数可用来获取一个类型的值，并产生另一个类型的值。两者具体的语法如下：CAST(value as type);CONVERT(value, type);即: CAST(xxx AS 类型), CONVERT(xxx,类型)。例如: SELECT CONVERT(‘23.00’, SIGNED); 可以转换的类型是有限制的。这个类型可以是以下值其中的一个：二进制，同带binary前缀的效果 : BINARY字符型，可带参数 : CHAR()日期 : DATE时间: TIME日期时间型 : DATETIME浮点数 : DECIMAL整数 : SIGNED无符号整数 : UNSIGNED 5.2.以汉字首字符排序name字段按照汉字正序 , 以name开头第一个字符来排序,依次是空格 0-9 a-z 字符 ,汉字首字拼音的首字母按照a-z来排序;select DISTINCT name from your_table order by convert(name using gbk) asc limit 300; 6. union 和 union all 的区别union在进行表求并集后会去掉重复的元素，所以会对所产生的结果集进行排序运算，删除重复的记录再返回结果。union all则只是简单地将两个结果集合并后就返回结果。因此，如果返回的两个结果集中有重复的数据，那么返回的结果就会包含重复的数据。tips: 使用联合查询,想区分结果集中的数据来自哪一张表,可以在查询中增加一个标志 1SELECT id,name ,1 as from_table_name FROM `teacher` union select id,name,2 as from_table_name from `student`; 7.获取每个分组下的前N条数据示例:找出各单位薪资前三高的员工 1234567891011121314151617181920212223-- ------------------------------ Table structure for user_salary-- ----------------------------DROP TABLE IF EXISTS `user_salary`;CREATE TABLE `user_salary` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Name` varchar(255) NOT NULL, `Salary` int(11) NOT NULL COMMENT '薪水', `DepartmentId` int(11) NOT NULL COMMENT '部门id', PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 COMMENT='各部门员工薪资表';-- ------------------------------ Records of user_salary-- ----------------------------INSERT INTO `user_salary` VALUES ('1', 'one_1', '2000', '1');INSERT INTO `user_salary` VALUES ('2', 'two_1', '3000', '1');INSERT INTO `user_salary` VALUES ('3', 'three_1', '1000', '1');INSERT INTO `user_salary` VALUES ('4', 'four_1', '4000', '1');INSERT INTO `user_salary` VALUES ('5', 'one_2', '8000', '2');INSERT INTO `user_salary` VALUES ('6', 'two_2', '5000', '2');INSERT INTO `user_salary` VALUES ('7', 'three_2', '6000', '2');INSERT INTO `user_salary` VALUES ('8', 'four_2', '7000', '2'); 由于mysql执行的先后顺序导致了不能简单的使用group by + order by + limit 来完成该查询;(1).查询示例: 123456789101112131415mysql&gt; SELECT * FROM `user_salary` as a where 3&gt;(SELECT count(*) FROM `user_salary` as b where b.`DepartmentId`=a.`DepartmentId` and b.`salary` &gt; a.`salary`)ORDER BY a.DepartmentId asc,a.Salary desc;+----+---------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+---------+--------+--------------+| 4 | four_1 | 4000 | 1 || 2 | two_1 | 3000 | 1 || 1 | one_1 | 2000 | 1 || 5 | one_2 | 8000 | 2 || 8 | four_2 | 7000 | 2 || 7 | three_2 | 6000 | 2 |+----+---------+--------+--------------+6 rows in setmysql&gt; 说明:采用逆向思维。各部门薪资最高的前三位，也就是薪资比该条记录的薪资还高的不能超过三条记录，即同一部门中,比当前记录薪资高的数据count(*)&lt;3; (2).修改下,第一种满足的数据出现大于所需条目的情况 1234-- 像部门2增加数据INSERT INTO `young`.`user_salary` (`Id`, `Name`, `Salary`, `DepartmentId`) VALUES ('9', 'five_2', '8000', '2');INSERT INTO `young`.`user_salary` (`Id`, `Name`, `Salary`, `DepartmentId`) VALUES ('10', 'six_2', '8000', '2');INSERT INTO `young`.`user_salary` (`Id`, `Name`, `Salary`, `DepartmentId`) VALUES ('11', 'seven_2', '8000', '2'); 同样的查询语句看结果: 12345678910111213141516mysql&gt; SELECT * FROM `user_salary` as a where 3&gt;(SELECT count(*) FROM `user_salary` as b where b.`DepartmentId`=a.`DepartmentId` and b.`salary` &gt; a.`salary`)ORDER BY a.DepartmentId asc,a.Salary desc;+----+---------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+---------+--------+--------------+| 4 | four_1 | 4000 | 1 || 2 | two_1 | 3000 | 1 || 1 | one_1 | 2000 | 1 || 5 | one_2 | 8000 | 2 || 9 | five_2 | 8000 | 2 || 10 | six_2 | 8000 | 2 || 11 | seven_2 | 8000 | 2 |+----+---------+--------+--------------+7 rows in setmysql&gt; 说明:可以看到部门2出现了四条满足情况的数据,因为最高的8000有四条;(如果我们只需三条,可以拿到后按照我们想要的顺序排序,然后程序代码控制只取前三条)(3). 类似(2)这样的,如果是想要不同值的前三名最高薪资,可以使用去重COUNT(DISTINCT expr,[expr…]) 12345678910111213141516171819mysql&gt; SELECT * FROM `user_salary` as a where 3&gt;(SELECT count(DISTINCT b.`salary`) FROM `user_salary` as b where b.`DepartmentId`=a.`DepartmentId` and b.`salary` &gt; a.`salary`)ORDER BY a.DepartmentId asc,a.Salary desc;+----+---------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+---------+--------+--------------+| 4 | four_1 | 4000 | 1 || 2 | two_1 | 3000 | 1 || 1 | one_1 | 2000 | 1 || 5 | one_2 | 8000 | 2 || 9 | five_2 | 8000 | 2 || 10 | six_2 | 8000 | 2 || 11 | seven_2 | 8000 | 2 || 8 | four_2 | 7000 | 2 || 7 | three_2 | 6000 | 2 |+----+---------+--------+--------------+9 rows in setmysql&gt; 参考和题目来源leetcode:https://blog.csdn.net/wzy_1988/article/details/52871636https://leetcode-cn.com/problems/department-top-three-salaries/]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
